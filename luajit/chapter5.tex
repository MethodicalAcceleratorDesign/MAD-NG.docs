\chapter{Traces investigation}
\begin{multicols}{2}
\noindent
\textbf{Prerequisites}\\
To read this chapter you are supposed to know: what is a tracing JIT; the mechanism of traces and side traces; what are intermediate representation (IR) and bytecode (see Chapter \ref{}).

\columnbreak
\noindent
\textbf{What you want to learn}\\
After reading this chapter you will learn how LuaJIT creates traces and how they are connected to each other.
\end{multicols}

\section{Introduction}
\noindent
The aim of this chapter is to show some examples in order to understand how traces are generated and organised by LuaJIT. 

The first paragraph clarifies with very simple loop examples how traces are generated by the compiler. The second and third paragraphs show how traces are connected with each other in more complex examples. Finally, the last paragraph investigates the case of recursive functions.

For each example it is described how the compiler behaves and it is shown: the LUA code of the example; the corresponding bytecode and IR generated; a flow diagram that refers to the IR.


\section{Simple examples}
The next examples show how the compiler creates traces in simple but significant cases: (i) empty loop, (ii) loop with assignment, (iii) loop with if-statement and (iv) nested loop.

\subsection{Empty loop}
It is interesting that even an empty loop generates a trace. When the loop becomes hot, the virtual machine (VM) starts to record the instructions and the types of their operands during the execution. Thus, it generates an equivalent intermediate representation (IR). 

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Empty loop

for i=1,100 do

end
\end{lstlisting}
\end{mdframed}

\noindent
In this case the bytecode produced contains just the \texttt{FORL} loop instruction.

\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
0005  FORL     0 => 0005
---- TRACE 1 stop -> loop
\end{lstlisting}

\noindent
On the other hand, the IR holds more interesting information because it shows the fact that the first iteration of the loop is unrolled.

\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
---- TRACE 1 IR
0001    int SLOAD  #1    CI
0002  + int ADD    0001  +1  
0003 >  int LE     0002  +100
0004 ------ LOOP ------------
0005  + int ADD    0002  +1  
0006 >  int LE     0005  +100
0007    int PHI    0002  0005
---- TRACE 1 stop -> loop
\end{lstlisting}

\noindent
The instruction at the first line \texttt{SLOAD} (stack slot load) is used to init the variable \textit{i} used by the loop where its left operand \#1 refers to the first variable slot and the right operand contains two flags: coalesce (C) and inherited (I) (see \ref{} for details about flags).

The next lines are supposed to contain the loop, but the same instructions are repeated twice. This is due to the fact that the first iteration of the loop is unrolled (lines \texttt{0002-0003}), then the actual loop (lines \texttt{0005-0006}) is shown after the \texttt{-- LOOP --} label (line \texttt{0004}). The first iteration ensures that pre-conditions for all subsequent instructions are met. \texttt{ADD} increments the loop counter \textit{i} and \texttt{LE} (left operand $\leq$ right operand) checks that its value is lower than 100. If this condition is not satisfied ($i>100$), the execution takes the trace exit at line \texttt{0003} or at line \texttt{0006}. Possible exits from the trace are indicated by the symbol $>$ in the second column of the instruction. If the condition is true ($i\leq100$) the execution flow makes a backward jump to the \texttt{-- LOOP --} label (line \texttt{0004}) and continues with the next iteration of the loop. It is important to highlight the fact that only the instructions at lines \texttt{0005-0006} are executed repeatedly.

Eventually, the \texttt{PHI} instruction positioned at the end of the looping trace (line \texttt{0007}) allows to merge values from different incoming path at control flow merge points \cite{SSA-form}. The left operand \texttt{0002} holds a reference to the initial value of \textit{i}, the right operand \texttt{0005} holds a reference to the value after each loop iteration. Operands of the PHI function are indicated by the symbol + in the second column of the IR (in this case lines \texttt{0002} and \texttt{0005}).

The diagram below explains the execution flows of the IR in a cleaner way. Specially for complex examples it will be easier to look at the diagram  to understand the IR.

% Diagram
\begin{figure}[H]
\hspace*{3cm}
\vspace*{-2.5cm}
\begin{tikzpicture}

%Nodes
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#1 \\
        i $\leftarrow$ i + 1\\
        ? i$\le$100};
\myblocknode{1}{0005} (node1) [below=of node0] (node1) [below=of node0]
        {i $\leftarrow$ i + 1\\
        ? i$\le$100};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};


% Lines TRACE 1
\draw[->] (init) -- (node0) ;
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1.south) .. controls +(down:40mm) and +(left:28mm) .. (node1.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};

%Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) ]{};
\node[label=\mylooplabel{0004}, frame_loop,fit= (node1)]{};


\end{tikzpicture}
\caption{Trace flow diagram empty loop}
\label{fig:trace-empty}
\end{figure}

\noindent
\begin{comment}
Explaining the IR in details would be to complex and tedious for the reader. Thus, from this example forward there will be a diagram that explains the execution  flows.  
\end{comment}
In the diagrams each trace is divided in blocks containing instructions with an unique identifier enclosed in squared brackets (e.g. \texttt{[0]}). On the top right of each block it is indicated the line in the IR of the first instruction in the block (e.g. \texttt{0001}). At the end of each block there could be a conditional expression that represents a guard. In the case that the guard is violated (the condition is false) the trace is exited, otherwise the execution continues in the next block of the trace. Possible exits are represented by the letter 'X' followed by their number (e.g. X1). By default an exit leads to the virtual machine. Note that when the execution flow exits from a trace, values on stack slots are restored.

\subsection{Loop with assignment}
This example has been designed to analyse what happens if the loop contains variable assignments. It will be shown that the compiler is able to move invariant instructions out of loops \cite{lj-mail-understand-ir} with the loop-invariant code motion (LICM) optimisation. Another small difference from the previous example is that the maximum loop counter is not a literal but it is a variable ($N=100$). 
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with assignment

local x = 0
local y = 0
local N = 100

for i=1,N do
	 y = 11
	 x = x + 22
end
\end{lstlisting}
\end{mdframed}

\noindent
As shown in the bytecode below, the instruction \texttt{KSHORT} (line \texttt{0008}) sets \textit{y} to 11 and \texttt{ADDVN} (line \texttt{0009}) computes the operation $x=x+22$. Here it is clear that at bytecode level the LICM optimisation is not applied because the execution flow makes a backward jump to line \texttt{0008} and $y=11$ is repeated at each iteration of the loop. In fact, no optimisation is performed by LuaJIT on bytecode.

\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
0008  KSHORT   1  11
0009  ADDVN    0   0   0  ; 22
0010  FORL     3 => 0008
---- TRACE 1 stop -> loop
\end{lstlisting}

\noindent
It should be noted that the initialisation of variable values are performed outside traces because these instruction are not executed repeatedly, but they are executed just once. 

In the IR below it is possible to see more details of what really occurs.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
---- TRACE 1 IR
0001 >  int SLOAD  #5    CRI
0002 >  int LE     0001  +2147483646
0003    int SLOAD  #4    CI
0004 >  num SLOAD  #1    T
0005  + num ADD    0004  +22 
0006  + int ADD    0003  +1  
0007 >  int LE     0006  0001
0008 ------ LOOP ------------
0009  + num ADD    0005  +22 
0010  + int ADD    0006  +1  
0011 >  int LE     0010  0001
0012    int PHI    0006  0010
0013    num PHI    0005  0009
---- TRACE 1 stop -> loop
\end{lstlisting}
\end{multicols} 

\noindent
The first two lines refer to the maximum loop counter \textit{N}: \texttt{SLOAD} (line \texttt{0001}) with flag read-only (R) is used to init \textit{N} and in line \texttt{0002} it is checked if its value falls into the signed 32-bit integer range ($N\leq+2147483646$). In this way, the compiler can discriminate if the loop will be done over integer or floating point values. The \texttt{SLOAD}s at lines \texttt{0003}-\texttt{0004} are used to init the variables \textit{i} and \textit{x} respectively. In particular \textit{x} has a flag of type check (T).

At IR level it is possible to see compiler optimisations. The value of \textit{x} changes at each iteration of the loop. Thus, the \texttt{ADD} instruction $x=x+22$ is contained both in the pre-loop (line \texttt{0005}) and in the actual loop (line \texttt{0009}). On the other hand, the expression $y=11$ can be moved outside the body of the loop by LICM without affecting the semantic of the program. This instruction will be executed only once outside the trace (in fact there is no line in the IR referring to it).

At the end of the dump there are two \texttt{PHI} functions. The first (line \texttt{0012}) refers to the variable \textit{i} as explained in the previous example. The second (line \texttt{0013}) refers to the variable \textit{x} and it is necessary for the same reason.

The graph below shows what just explained
.
% Diagram
\begin{figure}[H]
\hspace*{+3.5cm}
\vspace*{-2.5cm}
\begin{tikzpicture}

%Nodes
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { N $\leftarrow$ \#5 \\
        ? N:const};
\myblocknode{1}{0002} (node1) [below=of node0] (node1) [below=of node0]   
        {? N:int};
\myblocknode{2}{0003} (node2) [below=of node1]            
        {i $\leftarrow$ \#4\\
        x $\leftarrow$ \#1\\
        ? x:num};
\myblocknode{3}{0005} (node3) [below=of node2]   
        {x $\leftarrow$ x + 22\\
        i $\leftarrow$ i + 1\\
        ? i$\le$N};
\myblocknode{4}{0009} (node4) [below=of node3]             
        {x $\leftarrow$ x + 22\\
        i $\leftarrow$ i + 1\\
        ? i$\le$N};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};



% Lines TRACE 1
\draw[->] (init) -- (node0) ;
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4.south) .. controls +(down:40mm) and +(left:28mm) .. (node4.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};


%Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) (node2) (node3) (node4)]{};8\node[label=\mylooplabel{0008}, frame_loop,fit= (node4)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with assignment}
\label{fig:trace-if}
\end{figure}


\subsection{Loop with if-statements}
\label{subsec:if-statement}
In this example the goal is to investigate how the compiler creates traces when an if-statement is contained inside a loop.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with if-statement

local x = 0

for i=1,1e4 do
	x = x + 11
	if i%10 == 0 then   -- if-statement
		x = x + 22
	end
	x = x + 33
end
\end{lstlisting}
\end{mdframed}
In the loop showed above, the execution flow skips most of the times the instruction contained in the if-statement because the expression $i\%10==0$ is true only each 10 iterations of the loop. From $i=0$ forward, the instructions that are executed repeatedly the most are $x=x+11$ and $x=x+33$, thus the compiler creates a trace containing these instructions (\texttt{TRACE 1}). By increasing \textit{i}, the condition of the if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction within the if-statement and what follows.
 
 
 %% comment
 \begin{comment}
and when the loop becomes hot, the compiler generates a trace (TRACE 1) that contains all the instructions in the loop, but the one inside the if-statement. This happens because this set of instruction is executed repeatedly.

Later on, every time that is \textit{i} is multiple of 10, the instruction inside the if-statement is executed. This means that the same exit from the root trace (TRACE 1) is taken more and more frequently. Then, when this happens for enough times (as said before the default threshold is 56) the compiler generate a side trace (TRACE 2). It should be noted that the side trace contains both the instruction inside the if-statement $x=x+22$ and the next instruction $x=x+33$. 
 \end{comment}
The bytecode below shows more in details this method.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   0  ; 11
0007  MODVN    5   4   1  ; 10
0008  ISNEN    5   2      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   4  ; 33
0012  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
0010  ADDVN    0   0   3  ; 22
0011  ADDVN    0   0   4  ; 33
0012  JFORL    1   1
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The expression $x=x+11$ is computed at line \texttt{0006}. Then in line \texttt{0007} it is calculated $i\%10$ and in line \texttt{0008} it is checked that the result is not equal to zero. If the condition is true the execution flow jumps to the instruction at line \texttt{0011} where $x=x+33$ is computed and then line \texttt{0012} contains the loop backward branch. If the condition is false ($i\%10 = 0$) the \texttt{JMP} to 0011 is not taken. The execution flow goes from the instruction at line \texttt{0009} to the very next instruction at line \texttt{0010}. In fact, this is the link between the root trace (\texttt{TRACE 1}) and the side trace (\texttt{TRACE 2}). Finally, in the side trace both the \texttt{ADD} operations $x=x+22$ and $x=x+33$ are executed. To conclude the execution flow goes back to the parent trace \texttt{-- TRACE 2 stop -> 1}.

The IR follows the same logic. What changes is the fact that the first iteration of the loop is unrolled. Moreover, in the IR it is more clear how the two traces are connected to each other. At the very first line of the side trace \texttt{-- TRACE 2 start 1/4} the number 1 refers to the parent trace and 4 to the exit number that corresponds to line \texttt{0012} in \texttt{TRACE 1}. Line \texttt{0012} is the exit number 4 because it is the 4th line having as second column the symbol $>$ in \texttt{TRACE 1}.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +10 
0005 >  int NE     0004  +0  
0006  + num ADD    0003  +33 
0007  + int ADD    0001  +1  
0008 >  int LE     0007  +10000
0009 ------ LOOP ------------
0010    num ADD    0006  +11 
0011    int MOD    0007  +10 
0012 >  int NE     0011  +0  
0013  + num ADD    0010  +33 
0014  + int ADD    0007  +1  
0015 >  int LE     0014  +10000
0016    int PHI    0007  0014
0017    num PHI    0006  0013
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +10000
0007    num CONV   0005  num.int
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The diagram in Fig.\ref{fig:trace-if} shows the IR flow diagram for this example. \texttt{TRACE 1} is organised as follow: blocks \texttt{[0]},\texttt{[1]},\texttt{[2]} contain the loop unroll; blocks \texttt{[3]},\texttt{[4]} contain the actual loop; in block \texttt{[3]} there is a possible exit that leads to the side trace. At the end, when \texttt{TRACE 2} is finished, the execution flow joins \texttt{TRACE 1} in block \texttt{[0]}.

\begin{comment}
Possible side exits are indicated by the symbol $>$ in the IR dump. The number of the exit is related with the order in which it appears in the IR (e.g. the first $>$ symbol at line 0002 refers to the exit 1).
\end{comment}

% Diagram
\begin{figure}[H]
\hspace*{+1cm}
\vspace*{0cm}
\begin{tikzpicture}

%Nodes
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0] (node1) [below=of node0]   
            {x $\leftarrow$ x + 11\\                                    
            ? i\%10 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]            
            {x $\leftarrow$ x + 33\\
            i $\leftarrow$ i + 1\\
            ? i$\le$1e4};
\myblocknode{3}{0010} (node3) [below=of node2]   
            {x $\leftarrow$ x + 11\\
            ? i\%10 $\neq$ 0};
\myblocknode{4}{0013} (node4) [below=of node3]             
            {x $\leftarrow$ x + 33\\
            i $\leftarrow$ i + 1\\
            ? i$\le$1e4};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};


% Nodes TRACE 2
\myblocknode{5}{0001} (node5) [right=1.5cm of exit3]             
        {x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{6}{0004} (node6) [below=of node5]             
        {x $\leftarrow$ x + 33\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e4};
\node[emptynode] (exit6) [right=of node6] {X1};
\node[emptynode] (alias_trace1) [below=of node6] {[0]};

% Lines TRACE 1
\draw[->] (init) -- (node0) ;
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4.west) .. controls +(left:20mm) and +(left:20mm) .. (node3.west) node[near start , shift={(0.9,-0.1)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};

% Lines TRACE 2
\draw[->] (exit4.east) .. controls +(right:10mm) and +(left:10mm) .. (node5.west);
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node6) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (alias_trace1) node[near start, right] {\tiny{T}};

%Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) (node2) (node3) (node4)]{};
\node[label=TRACE 2, frame,fit=(node5) (node6)]{};
\node[label=\mylooplabel{0009}, frame_loop,fit= (node3) (node4)]{};


\end{tikzpicture}
\caption{Trace flow diagram loop with if-statement}
\label{fig:trace-if}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%% comment %%%%%%%%%%%
\begin{comment}
In Lines 0003-0008 contain the loop unrolled and lines 00010-0015 the actual loop. It is performed the modulus operation (MOD), it is checked that its result is not equal to zero (NE), then the loop is incremented (ADD) and  it is checked the loop termination (LE).


As it is showed in the dump here there are  two traces: the original root trace (TRACE 1) and a new trace (TRACE 2) called side trace. This is necessary because there is a branch (if-statement) in the code and traces are not allowed to have internal branches. The root trace will internally handle the case when the loop index is not multiple of 10 but it will exit to the side trace otherwise. The side trace then rejoins the root trace as is written in the dump \texttt{---- TRACE 2 stop -> 1}. The effect is that the loop alternates between saying inside the root trace and exiting to the side trace. Line 0005 contains a guard indicated by the symbol $>$ that is a possible exit from the trace.

TRACE 2:

The first two lines of TRACE 2 are simple init of the registers. Lines 0003-0009 take the reference and load \textit{x}. Then, in line 0010 it is executed $x=x+1$ and the result is stored (line 0011). Finally the loop is incremented (line 0012) and it is checked the loop termination (line 0013). The last line 0014 converts the number in integer.\\
\texttt{Ref. https://github.com/lukego/blog/issues/}\\
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%% end comment %%%%%%%%%%%

\subsection{Nested loop}
\label{subsec:nested-loop}
This example explains how the compiler generates traces in the case of nested loop. It creates a trace that refers to the inner loop  and another trace for the outer loop.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Nested loop

local x = 0

for i=1,1e4,2 do    -- outer loop
    x = x + 11
    for j=2,1e3,4 do    -- inner loop
        x = x + 22
    end
    x = x + 33
end
\end{lstlisting}
\end{mdframed}

\noindent
The instructions of the inner loop will be executed repeatedly at first. Thus, the inner loop becomes hot first and the compiler creates a trace (\texttt{TRACE 1}). At some point, also the outer loop becomes hot and the compiler generates another trace (\texttt{TRACE 2}) that is a side trace of the previous one.

Traces are organised in a reverse order if compared with the standard way of thinking the execution flow of nested loops. As it is shown in the bytecode below: \texttt{TRACE 1} contains the instruction $x=x+22$;  \texttt{TRACE 2} contains first the instruction $x=x+33$ and then $x=x+11$. Moreover, \texttt{TRACE 2} is a side trace that starts at the exit number 3 of \texttt{TRACE 1} (when the inner loop is finished).

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
0011  ADDVN    0   0   1  ; 22
0012  FORL     5 => 0011
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/3 Ex.lua:10
0013  ADDVN    0   0   2  ; 33
0014  FORL     1 => 0006
0006  ADDVN    0   0   0  ; 11
0007  KSHORT   5   2
0008  KSHORT   6 1000
0009  KSHORT   7   4
0010  JFORI    5 => 0013
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The method of organising traces for nested loops is more clear when looking at the IR and the diagram.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
---- TRACE 1 IR
0001    int SLOAD  #6    CI
0002 >  num SLOAD  #1    T
0003  + num ADD    0002  +22 
0004  + int ADD    0001  +4  
0005 >  int LE     0004  +1000
0006 ------ LOOP ------------
0007  + num ADD    0003  +22 
0008  + int ADD    0004  +4  
0009 >  int LE     0008  +1000
0010    int PHI    0004  0008
0011    num PHI    0003  0007
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/3 Ex.lua:10
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    num ADD    0001  +33 
0003    num SLOAD  #2    I
0004    num ADD    0003  +2  
0005 >  num LE     0004  +10000
0006    num ADD    0002  +11 
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

% Diagram
\begin{figure}[H]
\hspace*{0cm}
\vspace*{-2cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        {i $\leftarrow$ \#6 \\
         x $\leftarrow$ \#1 \\
         ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]   
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$1e3};
\myblocknode{2}{0007} (node2) [below=of node1]            
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$1e3};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};

% Nodes TRACE 2
\myblocknode{3}{0001} (node3) [right=1.5cm of exit2]
        {x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 33\\
        i $\leftarrow$ \#2 \\
        i $\leftarrow$ i + 2\\
        ? i$\le$1e4};
\myblocknode{4}{0006} (node4) [below=of node3]             
        {x $\leftarrow$ x + 11};
\node[emptynode] (exit4) [right=of node3] {X1};
\node[emptynode] (alias_trace1) [below=of node4] {[0]};

%Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2.south) .. controls +(down:40mm) and +(left:28mm) .. (node2.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};

% Lines TRACE 2
\draw[->] (exit3.east) .. controls +(right:10mm) and +(left:10mm) .. (node3.west);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (alias_trace1);

%Frames
\node[label=TRACE 1 ,frame,fit=(node0) (node1) (node2)] (trace1) {};
\node[label=TRACE 2 ,frame,fit=(node3) (node4)] (trace2) {};
\node[label=\mylooplabel{0006}, frame_loop,fit= (node2)]{};
\end{tikzpicture}
\caption{Trace flow diagram nested loop}
\end{figure}
\begin{comment}
TRACE 1 contains the instruction of the inner loop. At line 0001 SLOAD (store a value) is used to init the register used by the loop. Lines 0002-0008 take the reference and load \textit{x}. Lines 0009-0012 contain the loop unrolled and lines 0014-0017 the actual loop. The value of x is incremented by 1 (ADD) and the result is stored (HSTORE), then the loop is incremented (ADD) and  it is checked the loop termination (LE). Then, in line 0010 it is executed $x=x+1$ and the result is stored (line 0011). Finally the loop is incremented (line 0012) and it is checked the loop termination (line 0013). The last line 0014 converts the number in integer.

In TRACE 2 it is shown the instruction related to the outer loop. In this case is computed the operation $x=x*3$ (line 0011). The other lines show instruction previously described.\\

\end{comment}
\noindent
The outer loop (\texttt{TRACE 2}) goes around the inner loop (\texttt{TRACE 1}) and joins it in block \texttt{[0]}.

On the other hand, if the inner loop had low iteration count, it would be unrolled and inlined \cite{lj-mail-understand-compiler}.

\newpage

\section{Loop with two if-statements}
\label{section:2-if-statements}

In this section it will be explored how the JIT-compiler organises traces when there are two different if-statements within the same loop. The cases investigated are as follow: (i) the first if-statement condition becomes true before the second; (ii) the second becomes true before the first; (iii) the if-statement conditions become true at different time; (iv) the if-statement conditions become true at the same time.

\subsection{Example 1}
\label{2-if-example1}
This example shows how traces are organised in a loop with 2 if-statements when the first condition becomes true before the second. In this case the truthfulness of the second if-condition implies the first.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement Example 1

local x = 0

for i=1,1e6 do
	x = x + 11
    if i%10 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
    if i%20 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}
As it happened in the example \ref{subsec:if-statement}, the execution flow skips most of the times the instructions contained in the if-statements and the compiler creates a trace (\texttt{TRACE 1}) with the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of the first if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction within the first if-statement $x=x+22$ and what follows. At some point, also the condition of the second if-statement becomes true repeatedly, thus the compiler creates a trace (\texttt{TRACE 3}) with the instruction within the second if-statement $x=x+44$ and what follows.
% comment
\begin{comment}
The side exit that corresponds to the first if-statement is taken more often than the second. Thus, the first side trace to be generated (TRACE 2) refers to the first if-statement. Then, when the side exit that corresponds to the second side trace is taken enough times, another side trace will be created (TRACE 3). It should be noted that in this case TRACE 3 is a side trace of TRACE 2, while TRACE 2 is a side trace of TRACE 1.
The code above generates the following bytecode dump. TRACE 1 contains all the instructions, but the ones inside the if-statements (lines 7 and 11); TRACE 2 the instructions inside the first if-statement and what follows; TRACE 3 the instructions inside the second if-statement and what follows.
\end{comment}

The bytecode below shows what just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 10
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1

---- TRACE 3 start 2/1 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
Links between traces are more explicit in the IR and in the diagram.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +10 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007    int MOD    0001  +20 
0008 >  int NE     0007  +0  
0009  + num ADD    0006  +55 
0010  + int ADD    0001  +1  
0011 >  int LE     0010  +1000000
0012 ------ LOOP ------------
0013    num ADD    0009  +11 
0014    int MOD    0010  +10 
0015 >  int NE     0014  +0  
0016    num ADD    0013  +33 
0017    int MOD    0010  +20 
0018 >  int NE     0017  +0  
0019  + num ADD    0016  +55 
0020  + int ADD    0010  +1  
0021 >  int LE     0020  +1000000
0022    int PHI    0010  0020
0023    num PHI    0009  0019
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +20 
0006 >  int NE     0005  +0  
0007    num ADD    0004  +55 
0008    int ADD    0002  +1  
0009 >  int LE     0008  +1000000
0010    num CONV   0008  num.int
---- TRACE 2 stop -> 1

---- TRACE 3 start 2/1 Ex.lua:12
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
Generally side traces are created when an exit is taken repeatedly. In this case \texttt{TRACE 2} starts at the exit number 5 of \texttt{TRACE 1} (line \texttt{0015}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 3} starts at the exit number 1 of \texttt{TRACE 2} (line \texttt{0006}) and it joins \texttt{TRACE 2} at the end. Thus, \texttt{TRACE 2} is a side trace of \texttt{TRACE 1} and \texttt{TRACE 3} is a side trace of \texttt{TRACE 2}.
% Diagram
\begin{figure}[H]
\hspace*{-1cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{3}{0009} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0013} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{5}{0016} (node5) [below=of node4]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{6}{0019} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit6) [right=of node5] {X6};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right=of exit4]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node9] {X2};
\node[emptynode] (alias1_trace1) [below=of node9] {[0]};

% Nodes TRACE 3
\myblocknode{10}{0001} (node10) [right=of exit1_trace2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{11}{0004} (node11) [below=of node10]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace3) [right=of node11] {X1};
\node[emptynode] (alias2_trace1) [below=of node11] {[0]};
    
% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:10mm) and +(left:10mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit1_trace2) -- (node10);
\draw[->] (node10) -- (node11);
\draw[->] (node11) -- (exit1_trace3) node[near start, above] {\tiny{F}};
\draw[->] (node11) -- (alias2_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0012}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,fit=(node7) (node8) (node9)]{};
\node[label=TRACE 3, frame,fit=(node10) (node11)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 1}
\end{figure}

\newpage

\subsection{Example 2}
\label{2-if-example2}
This example is the same as the previous one, but the order of the two if-statement is reversed. In particular, it investigates how traces are organised in a loop with two if-statements when the second condition  becomes true before the first. In  this case the truthfulness of the first if-condition implies the second. 

Even if the change from the previous example is small, it causes a big difference in the traces organisation.
% comment The second if-statement generates a side trace before the first because the condition \texttt{i\%10==0} becomes true twice more than \texttt{i\%20==0} (again this is due the fact that 20 is multiple of 10). The side exit that corresponds to the second if-statement is taken more times than the first. Thus, the first side trace to be generated (TRACE 2) refers to the second if-statement. Then, when the side exit that corresponds to the second side trace is taken for enough times, another side trace will be created (TRACE 3). It should be noted that the structure is completely different from Example \ref{2-if-example1} because both TRACE 3 and TRACE 2 are side traces of TRACE 1.

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement Example 2

local x = 0

for i=1,1e6 do
	x = x + 11
	if i%20 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
	if i%10 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}

\noindent
The compiler creates the first trace (\texttt{TRACE 1}) with the same logic of the previous example. It contains the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of the second if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 3}) that contains the instruction within the second if-statement $x=x+44$ and what follows. At some point, also the condition of the first if-statement becomes true repeatedly, thus the compiler creates a trace (\texttt{TRACE 2}) that contains instructions within both the if-statements and what follows.
%The code above generates the following bytecode dump. TRACE 1 contains all the instructions, but the ones inside the if-statements; TRACE 2 the instructions inside the second if-statement and what follows; TRACE 3 the instructions inside both the if-statements and what follows.

The bytecode below shows what just explained.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 20
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}
%In the IR it is possible to see the side traces chain of calls.  TRACE 2 starts at the exit number 5 of TRACE 1 (line 0015) and it joins TRACE 1 at the end.  TRACE 3 starts at the exit number 6 of TRACE 1 (line 0018) and it joins TRACE 1 at the end.

\noindent
The IR displayed below shows that \texttt{TRACE 2} starts at the exit number 5 of \texttt{TRACE 1} (line \texttt{0015}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 3} starts at the exit number 6 of \texttt{TRACE 1} (line \texttt{0018}) and it joins \texttt{TRACE 1} at the end. Thus, both \texttt{TRACE 2} and \texttt{TRACE 3} are side traces of  \texttt{TRACE 1}.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +20 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007    int MOD    0001  +10 
0008 >  int NE     0007  +0  
0009  + num ADD    0006  +55 
0010  + int ADD    0001  +1  
0011 >  int LE     0010  +1000000
0012 ------ LOOP ------------
0013    num ADD    0009  +11 
0014    int MOD    0010  +20 
0015 >  int NE     0014  +0  
0016    num ADD    0013  +33 
0017    int MOD    0010  +10 
0018 >  int NE     0017  +0  
0019  + num ADD    0016  +55 
0020  + int ADD    0010  +1  
0021 >  int LE     0020  +1000000
0022    int PHI    0010  0020
0023    num PHI    0009  0019
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +10 
0006 >  int EQ     0005  +0  
0007    num ADD    0004  +44 
0008    num ADD    0007  +55 
0009    int ADD    0002  +1  
0010 >  int LE     0009  +1000000
0011    num CONV   0009  num.int
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
It is possible to make a comparison between this example and the previous one. From a programming point of view it is better to put first the if-condition that becomes true the most because when both the if-conditions are true the execution flow will only go through one side trace (e.g. \texttt{TRACE 2} in Example 2). Otherwise, it would go through a chain of side traces (e.g. \texttt{TRACE 2} and \texttt{TRACE 3} in Example 1). Thus, the way of programming in Example 2 should be preferred to Example 1.

% Diagram
\begin{figure}[H]
\hspace*{+1cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{3}{0009} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0013} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{5}{0016} (node5) [below=of node4]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{6}{0019} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit6) [right=of node5] {X6};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right=of exit1]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%10 = 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 44};
\myblocknode{10}{0009} (node10) [below=of node9]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};

\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node10] {X2};
\node[emptynode] (alias1_trace1) [below=of node10] {[0]};

% Nodes TRACE 3
\myblocknode{11}{0001} (node11) [right=of exit6]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{12}{0004} (node12) [below=of node11]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace3) [right=of node12] {X1};
\node[emptynode] (alias2_trace1) [below=of node12] {[0]};
    
% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:10mm) and +(left:12mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node9) -- (node10);
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit6) -- (node11);
\draw[->] (node11) -- (node12);
\draw[->] (node12) -- (exit1_trace3) node[near start, above] {\tiny{F}};
\draw[->] (node12) -- (alias2_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0012}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,fit=(node7) (node8) (node9) (node10)]{};
\node[label=TRACE 3, frame,fit=(node11) (node12)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 2}
\end{figure}

\newpage

\subsection{Example 3}
\label{2-if-example3}
This example shows how traces are organised in a loop with two if-statements when both conditions become true at the same time. The compiler does not generate a side trace for each if-statement, but it creates only a unique side trace. In this case the truthfulness of the first if-condition implies the second and vice versa.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement  Example 3

local x = 0

for i=1,1e6 do
	x = x + 11
	if i%10 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
	if i%10 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}
The compiler produces the first trace (\texttt{TRACE 1}) with the same logic of the previous examples. It contains the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of both if-statements becomes true at the same time more and more often. Thus, the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction within both the if-statements and what follows.

The bytecode below shows what just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 10
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   2  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   7  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   2  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0015  ADDVN    0   0   6  ; 44
0016  ADDVN    0   0   7  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
In the IR below it is shown that \texttt{TRACE 2} starts at the exit number 4 of \texttt{TRACE 1} (line \texttt{0013}) and it joins \texttt{TRACE 1} at the end. The exit of \texttt{TRACE 2} at \texttt{line 0006} will never be taken because $i\%10 = 0$ will always be true, since this was the condition that led the execution flow to enter in the side trace itself (see Diagram \ref{fig:2-if-ex3}).

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +10 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007  + num ADD    0006  +55 
0008  + int ADD    0001  +1  
0009 >  int LE     0008  +1000000
0010 ------ LOOP ------------
0011    num ADD    0007  +11 
0012    int MOD    0008  +10 
0013 >  int NE     0012  +0  
0014    num ADD    0011  +33 
0015  + num ADD    0014  +55 
0016  + int ADD    0008  +1  
0017 >  int LE     0016  +1000000
0018    int PHI    0008  0016
0019    num PHI    0007  0015
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +10 
0006 >  int EQ     0005  +0  
0007    num ADD    0004  +44 
0008    num ADD    0007  +55 
0009    int ADD    0002  +1  
0010 >  int LE     0009  +1000000
0011    num CONV   0009  num.int
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

% Diagram
\begin{figure}[H]
\hspace*{+1cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33};
\myblocknode{3}{0007} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0011} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{5}{0014} (node5) [below=of node4]
        {x $\leftarrow$ x + 33};
\myblocknode{6}{0015} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right =3cm of node2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%10 = 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 44};
\myblocknode{10}{0008} (node10) [below=of node9]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};

\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node10] {X2};
\node[emptynode] (alias1_trace1) [below=of node10] {[0]};

    
% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6);
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}]  {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:10mm) and +(left:10mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node9) -- (node10) node[near start, right] {\tiny{T}};
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0010}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,inner sep=5mm, fit=(node7) (node8) (node9) (node10)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 3}
\label{fig:2-if-ex3}
\end{figure}

\newpage

\subsection{Example 4}
\label{2-if-example4}
This example shows how traces are organised in a loop with two if-statements when the first condition becomes true before the second, but the  conditions become true mostly at different time. In this case the  truthfulness of the second implies the first just for some iteration of the loop (eg. $i = 60, 120, ...$).

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement Example 4

local x = 0

for i=1,1e6 do
	x = x + 11
	if i%15 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
	if i%20 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}

\noindent
The compiler creates the first trace (\texttt{TRACE 1}) with the same logic of the previous examples. It contains the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of the first if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction within the first if-statement $x=x+22$ and what follows. At some point, also the condition of the second if-statement becomes true repeatedly, thus the compiler creates a trace (\texttt{TRACE 3}) with the instruction within the second if-statement $x=x+44$ and what follows. Both \texttt{TRACE 2} and \texttt{TRACE 3} are side trace of \texttt{TRACE 1}.
 
 Later on, when both the conditions becomes true at the same time repeatedly, the compiler generates another trace (\texttt{TRACE 4}) that contains the instruction within the second if-statement $x=x+44$ and what follows. \texttt{TRACE 4} starts as a side trace of \texttt{TRACE 2}.

The bytecode below shows what just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 15
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 3 stop -> 1

---- TRACE 4 start 2/1 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The IR displayed below shows that \texttt{TRACE 2} starts at the exit number 5 of \texttt{TRACE 1} (line \texttt{0015}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 3} starts at the exit number 6 of \texttt{TRACE 1} (line \texttt{0018}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 4} starts at the exit number 1 of \texttt{TRACE 2} (line \texttt{0006}) and it joins \texttt{TRACE 1} at the end. 


\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +15 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007    int MOD    0001  +20 
0008 >  int NE     0007  +0  
0009  + num ADD    0006  +55 
0010  + int ADD    0001  +1  
0011 >  int LE     0010  +1000000
0012 ------ LOOP ------------
0013    num ADD    0009  +11 
0014    int MOD    0010  +15 
0015 >  int NE     0014  +0  
0016    num ADD    0013  +33 
0017    int MOD    0010  +20 
0018 >  int NE     0017  +0  
0019  + num ADD    0016  +55 
0020  + int ADD    0010  +1  
0021 >  int LE     0020  +1000000
0022    int PHI    0010  0020
0023    num PHI    0009  0019
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +20 
0006 >  int NE     0005  +0  
0007    num ADD    0004  +55 
0008    int ADD    0002  +1  
0009 >  int LE     0008  +1000000
0010    num CONV   0008  num.int
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 3 stop -> 1

---- TRACE 4 start 2/1 Ex.lua:12
---- TRACE 4 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
Possible trace paths covered by the execution flow are: (i) \texttt{TRACE 1}: if both conditions are false; (ii) \texttt{TRACE 1}, \texttt{TRACE 2}: if the first condition is true and the second is false; (iii) \texttt{TRACE 1}, \texttt{TRACE 3}: if the first condition is false and the second is true; (iv) \texttt{TRACE 1}, \texttt{TRACE 2}, \texttt{TRACE 4}: if both conditions are true.

% Diagram
\begin{figure}[H]
\hspace*{-0.5cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{3}{0009} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0013} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{5}{0016} (node5) [below=of node4]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{6}{0019} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit6) [right=of node5] {X6};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right=of exit2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node9] {X2};
\node[emptynode] (alias1_trace1) [below=of node9] {[0]};

% Nodes TRACE 3
\myblocknode{10}{0001} (node10) [right=of exit6]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{11}{0004} (node11) [below=of node10]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace3) [right=of node11] {X1};
\node[emptynode] (alias2_trace1) [below=of node11] {[0]};
    
% Nodes TRACE 4
\myblocknode{12}{0001} (node12) [right=of exit1_trace2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{13}{0004} (node13) [below=of node12]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace4) [right=of node13] {X1};
\node[emptynode] (alias3_trace1) [below=of node13] {[0]};
    

% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:15mm) and +(left:12mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit6) -- (node10);
\draw[->] (node10) -- (node11);
\draw[->] (node11) -- (exit1_trace3) node[near start, above] {\tiny{F}};
\draw[->] (node11) -- (alias2_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 4
\draw[->] (exit1_trace2) -- (node12);
\draw[->] (node12) -- (node13);
\draw[->] (node13) -- (exit1_trace4) node[near start, above] {\tiny{F}};
\draw[->] (node13) -- (alias3_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0012}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,fit=(node7) (node8) (node9) (node9)]{};
\node[label=TRACE 3, frame,fit=(node10) (node11)]{};
\node[label=TRACE 4, frame,fit=(node12) (node13)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 4}
\label{fig:}
\end{figure}

\newpage

\section{Nested loop with more inner loops}
\label{section:2-inner-loops}

The goal of this example is to explain how the compiler organises traces in the case of nested loop with two (or more) inner loops. The compiler generates: a trace for each inner loop, a trace (or more) to connect them
and a trace for the outer loop that goes around the inner loops.

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Nested loop with 2 inner loops

local x = 0

for i=1,1e4,2 do        -- outer loop
	x = x + 11
    for j=3,2e4,4 do    -- inner loop (LOOP 1)
		x = x + 22
	end
	x = x + 33
    for k=5,3e4,6 do    -- inner loop (LOOP 2)
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}

\noindent
In this case the instructions of the inner loops will be executed repeatedly at first. Thus, the inner loops become hot first and the compiler creates a trace for each of them (\texttt{TRACE 1}, \texttt{TRACE 2}). At some point, also the outer loop becomes hot and the compiler generates a trace (\texttt{TRACE 3}) to connect the two inner loops (with the instruction $x=x+33$) and a trace (\texttt{TRACE 4}) that goes around the inner loops (with the instructions $x=x+55$, $x=x+11$).

The bytecode below shows what just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start *.lua:7
0011  ADDVN    0   0   1  ; 22
0012  FORL     5 => 0011
---- TRACE 1 stop -> loop

---- TRACE 2 start *.lua:11
0018  ADDVN    0   0   3  ; 44
0019  FORL     5 => 0018
---- TRACE 2 stop -> loop

---- TRACE 3 start 1/3 *.lua:10
0013  ADDVN    0   0   2  ; 33
0014  KSHORT   5   5
0015  KSHORT   6 30000
0016  KSHORT   7   6
0017  JFORI    5 => 0020
---- TRACE 3 stop -> 2

---- TRACE 4 start 2/3 *.lua:14
0020  ADDVN    0   0   4  ; 55
0021  FORL     1 => 0006
0006  ADDVN    0   0   0  ; 11
0007  KSHORT   5   3
0008  KSHORT   6 20000
0009  KSHORT   7   4
0010  JFORI    5 => 0013
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

\newpage
\noindent
The IR shows the details of the traces organisation. \texttt{TRACE 1} and \texttt{TRACE 2} are independent traces. \texttt{TRACE 3} starts at the exit number 3 of \texttt{TRACE 1} (line \texttt{0009}) and it joins \texttt{TRACE 2} at the end (this is the connection of the two inner loops). \texttt{TRACE 4} starts at the exit number 3 of \texttt{TRACE 2} (line \texttt{0009}) and it joins \texttt{TRACE 1} at the end (this is the part of the outer loop that goes around the inner loops).

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start *.lua:7
---- TRACE 1 IR
0001    int SLOAD  #6    CI
0002 >  num SLOAD  #1    T
0003  + num ADD    0002  +22 
0004  + int ADD    0001  +4  
0005 >  int LE     0004  +20000
0006 ------ LOOP ------------
0007  + num ADD    0003  +22 
0008  + int ADD    0004  +4  
0009 >  int LE     0008  +20000
0010    int PHI    0004  0008
0011    num PHI    0003  0007
---- TRACE 1 stop -> loop

---- TRACE 2 start *.lua:11
---- TRACE 2 IR
0001    int SLOAD  #6    CI
0002 >  num SLOAD  #1    T
0003  + num ADD    0002  +44 
0004  + int ADD    0001  +6  
0005 >  int LE     0004  +30000
0006 ------ LOOP ------------
0007  + num ADD    0003  +44 
0008  + int ADD    0004  +6  
0009 >  int LE     0008  +30000
0010    int PHI    0004  0008
0011    num PHI    0003  0007
---- TRACE 2 stop -> loop

---- TRACE 3 start 1/3 *.lua:10
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    num ADD    0001  +33 
---- TRACE 3 stop -> 2

---- TRACE 4 start 2/3 *.lua:14
---- TRACE 4 IR
0001    num SLOAD  #1    PI
0002    num ADD    0001  +55 
0003    num SLOAD  #2    I
0004    num ADD    0003  +2  
0005 >  num LE     0004  +10000
0006    num ADD    0002  +11 
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

\newpage

% Diagram
\begin{figure}[H]
\hspace*{-2.7cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$2e4};
\myblocknode{2}{0007} (node2) [below=of node1]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$2e4};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};


% Nodes TRACE 2
\myblocknode{3}{0001} (node3) [right=3.8cm of exit1]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{4}{0003} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 6\\
        ? k$\le$3e4};
\myblocknode{5}{0007} (node5) [below=of node4]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 6\\
        ? k$\le$3e4};
\node[emptynode] (exit1_trace2) [right=of node3] {X1};
\node[emptynode] (exit2_trace2) [right=of node4] {X2};
\node[emptynode] (exit3_trace2) [right=of node5] {X3};

% Nodes TRACE 3
\myblocknode{6}{0001} (node6)[below right=3cm and 0cm of exit3]
        { x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 33};
    
% Nodes TRACE 4
\myblocknode{7}{0001} (node7)[below right=3cm and 0cm of exit3_trace2]
        { x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 55\\
        i $\leftarrow$ \#2 \\
        i $\leftarrow$ i + 2\\
        ? i$\le$1e4};
\myblocknode{8}{0006} (node8)[below=of node7]
        {  x $\leftarrow$ x + 11};
\node[emptynode] (exit1_trace4) [right=of node7] {X1};
\node[emptynode] (alias1_trace1) [below=of node8] {[0]};

    

% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node2.south) .. controls +(down:40mm) and +(left:28mm) .. (node2.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (node6.east) .. controls +(right:10mm) and +(left:25mm) .. (node3.west);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit3_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5.south) .. controls +(down:40mm) and +(left:28mm) .. (node5.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit3.south) .. controls +(down:20mm) and +(left:5mm) .. (node6.west);

% Lines TRACE 4
\draw[->] (exit3_trace2.south) .. controls +(down:20mm) and +(left:5mm) .. (node7.west);
\draw[->] (node7) -- (node8) node[near start, right] {\tiny{T}};
\draw[->] (node7) -- (exit1_trace4) node[near start, above] {\tiny{F}};
\draw[->] (node8) -- (alias1_trace1);



% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) ]{};
\node[label=TRACE 2, frame,fit=(node3) (node4) (node5)]{};
\node[label=TRACE 3, frame,fit=(node6)]{};
\node[label=TRACE 4, frame,fit=(node7) (node8)]{};
\node[label={[shift={(-1,0)}]LOOP 1}, frame_loop,fit= (node2) ]{};
\node[label={[shift={(-1,0)}]LOOP 2}, frame_loop,fit= (node5) ]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 inner loops}
\label{fig:}
\end{figure}

\noindent
The same structure is maintained when the number of inner loops increases. If \textit{n} is the number of inner loops, the compiler generates: \textit{n} traces for the \textit{n} inner loops, $n-1$ traces to connect the inner loops and a final trace for the outer loop that goes around the inner loops.

The code above describes the case of $n=3$.

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Nested loop with 3 inner loops

local x = 0

for i=1,1e4 do          -- outer loop
	x = x + 11
    for j=1,2e4,2 do    -- inner loop (LOOP 1)
		x = x + 22
	end
	x = x + 33
    for k=1,3e4,3 do    -- inner loop (LOOP 2)
		x = x + 44 
	end
	x = x + 55
    for t=1,4e4,4 do    -- inner loop (LOOP 3)
		x = x + 66
	end
	x = x + 77 
end
\end{lstlisting}
\end{mdframed}

% Diagram
% This diagram comes from copy paste of the previous one. The number of traces and block do not correspond to the one you see in the diagram:
% TRACE 1 -> TRACE 1; TRACE 2 -> TRACE 5; TRACE 3 -> TRACE 2; TRACE 4 -> TRACE 3; TRACE 5 -> TRACE 6; TRACE 6 -> TRACE 4 
\begin{figure}[H]
\begin{adjustwidth}{-2.8cm}{0cm}

\resizebox{18cm}{10cm}{

\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{*} (node0) [right=of init]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{*} (node1) [below=of node0]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 2\\
        ? j$\le$2e4};
\myblocknode{2}{*} (node2) [below=of node1]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 2\\
        ? j$\le$2e4};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};

% Nodes TRACE 2 (old TRACE 5)
\node[emptynode] (init) {};
\myblocknode{3}{*} (node9) [right=3.8cm of exit1]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{4}{*} (node10) [below=of node9]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 3\\
        ? k$\le$3e4};
\myblocknode{5}{*} (node11) [below=of node10]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 3\\
        ? k$\le$3e4};
\node[emptynode] (exit1_trace5) [right=of node9] {X1};
\node[emptynode] (exit2_trace5) [right=of node10] {X2};
\node[emptynode] (exit3_trace5) [right=of node11] {X3};

% Nodes TRACE 3 (old TRACE 2)
\myblocknode{6}{*} (node3) [right=3.8cm of exit1_trace5]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{7}{*} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 66\\
        t $\leftarrow$ t + 4\\
        ? t$\le$4e4};
\myblocknode{8}{*} (node5) [below=of node4]
        {x $\leftarrow$ x + 66\\
        t $\leftarrow$ t + 4\\
        ? t$\le$4e4};
\node[emptynode] (exit1_trace2) [right=of node3] {X1};
\node[emptynode] (exit2_trace2) [right=of node4] {X2};
\node[emptynode] (exit3_trace2) [right=of node5] {X3};


% Nodes TRACE 4 (old TRACE 3)
\myblocknode{9}{*} (node6)[below right=3cm and 0cm of exit3]
        {x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 33};
        
% Nodes TRACE 5 (old TRACE 6)
\myblocknode{10}{*} (node12)[below right=3cm and 0cm of exit3_trace5]
        {x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 55};
    
% Nodes TRACE 6 (old TRACE 4)
\myblocknode{11}{*} (node7)[below right=3cm and 0cm of exit3_trace2]
        { x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 77\\
        i $\leftarrow$ \#2 \\
        i $\leftarrow$ i + 2\\
        ? i$\le$1e4};
\myblocknode{12}{*} (node8)[below=of node7]
        {x $\leftarrow$ x + 11};
\node[emptynode] (exit1_trace4) [right=of node7] {X1};
\node[emptynode] (alias1_trace1) [below=of node8] {[0]};

% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node2.south) .. controls +(down:40mm) and +(left:28mm) .. (node2.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 2 (old TRACE 5) 
\draw[->] (node6.east) .. controls +(right:10mm) and +(left:25mm) .. (node9.west);
\draw[->] (node9) -- (node10) node[near start, right] {\tiny{T}};
\draw[->] (node10) -- (node11) node[near start, right] {\tiny{T}};
\draw[->] (node9) -- (exit1_trace5) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (exit2_trace5) node[near start, above] {\tiny{F}};
\draw[->] (node11) -- (exit3_trace5) node[near start, above] {\tiny{F}};
\draw[->] (node11.south) .. controls +(down:40mm) and +(left:28mm) .. (node11.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 3 (old TRACE 2)
\draw[->] (node12.east) .. controls +(right:10mm) and +(left:25mm) .. (node3.west);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit3_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5.south) .. controls +(down:40mm) and +(left:28mm) .. (node5.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 4 (old TRACE 3)
\draw[->] (exit3.south) .. controls +(down:20mm) and +(left:5mm) .. (node6.west);

% Lines TRACE 5 (old TRACE 6)
\draw[->] (exit3_trace5.south) .. controls +(down:20mm) and +(left:5mm) .. (node12.west);

% Lines TRACE 6 (old TRACE 4)
\draw[->] (exit3_trace2.south) .. controls +(down:20mm) and +(left:5mm) .. (node7.west);
\draw[->] (node7) -- (node8) node[near start, right] {\tiny{T}};
\draw[->] (node7) -- (exit1_trace4) node[near start, above] {\tiny{F}};
\draw[->] (node8) -- (alias1_trace1);

% Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) (node2) ]{};
\node[label=TRACE 3, frame,fit= (node3) (node4) (node5)]{};
\node[label=TRACE 4, frame,fit= (node6)]{};
\node[label=TRACE 6, frame,fit= (node7) (node8)]{};
\node[label=TRACE 2, frame,fit= (node9) (node10) (node11)]{};
\node[label=TRACE 5, frame,fit= (node12)]{};
\node[label={[shift={(-1,0)}]LOOP 2}, frame_loop,fit= (node11) ]{};
\node[label={[shift={(-1,0)}]LOOP 1}, frame_loop,fit= (node2) ]{};
\node[label={[shift={(-1,0)}]LOOP 3}, frame_loop,fit= (node5) ]{};

\end{tikzpicture}

}
\caption{Trace flow diagram loop with 3 inner loops}
\label{fig:}
\end{adjustwidth}
\end{figure}

\newpage
%-----------------------------------------------
% Function
%-----------------------------------------------
\section{Function}
In this section it will be shown what is the behaviour of the compiler when dealing with recursive functions. In particular, both non-tail recursive and tail recursive functions have been investigated.
\subsection{Non-tail recursive function}
This example consists in a non-tail recursive factorial function. The compiler does not create a loop structure because the function is non-tail recursive.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Non-tail recursive factorial

local function factorial(n)
  if n > 0 then
    return n * factorial(n-1)
  end
  return 1
end
\end{lstlisting}
\end{mdframed}

\noindent
The function calls itself as a standard recursive function. Since it is non-tail recursive, when making a recursive call, the return address needs to be pushed onto the call stack then jump to the called function. This means that it needs a call stack whose size is linear with the depth of the recursive calls.

In the bytecode below the depth of the recursive calls is represented by dots in the second column. In this case the compiler unrolls three recursive calls. Thus, the trace created contains three function calls with the instruction \texttt{FUNCF} (lines \texttt{0000}) and it ends with an up-recursion \texttt{-- TRACE 1 stop -> up-recursion}.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
0001  KSHORT   1   0
0002  ISGE     1   0
0003  JMP      1 => 0009
0004  UGET     1   0; factorial
0005  SUBVN    2   0   0  ; 1
0006  CALL     1   2   2
0000  . FUNCF    3  ; Ex.lua:3
0001  . KSHORT   1   0
0002  . ISGE     1   0
0003  . JMP      1 => 0009
0004  . UGET     1   0 ; factorial
0005  . SUBVN    2   0   0  ; 1
0006  . CALL     1   2   2
0000  . . FUNCF    3 ; Ex.lua:3
0001  . . KSHORT   1   0
0002  . . ISGE     1   0
0003  . . JMP      1 => 0009
0004  . . UGET     1   0 ; factorial
0005  . . SUBVN    2   0   0  ; 1
0006  . . CALL     1   2   2
0000  . . . FUNCF    3 ; Ex.lua:3
---- TRACE 1 stop -> up-recursion
\end{lstlisting}
\end{multicols}

\noindent
The IR generated is the following.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
---- TRACE 1 IR
0001 >  num SLOAD  #1    T
0002 >  num GT     0001  +0  
0003    fun SLOAD  #0    R
0004 >  fun EQ     0003  Ex.lua:3
0005    num SUB    0001  +1  
0006 >  num GT     0005  +0  
0007    num SUB    0005  +1  
0008 >  num GT     0007  +0  
0009    num SUB    0007  +1  
---- TRACE 1 stop -> up-recursion
\end{lstlisting}
\end{multicols}

\subsection{Tail recursive function}
This example consists in a tail recursive factorial function. In this case, the compiler create a loop structure because the function is tail recursive.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Tail recursive factorial

local function factorial(n, r)
  r = r or 1
  if n > 0 then
    return factorial(n-1, n*r)
  end
  return r
end
\end{lstlisting}
\end{mdframed}

\noindent
Since the function is tail recursive as soon as there is a return from the recursive call the execution flows goes immediately to a return as well. It skips the entire chain of recursive functions returning and it returns straight to the original caller. There is no need of a call stack for the recursive calls.

As a matter of fact, there are no dots in the bytecode below because there is no depth of recursive calls. Also in this case the compiler unrolls three recursive calls. Thus, the trace created contains three function calls with the instruction \texttt{FUNCF} (lines \texttt{0000}) and it ends with a tail recursion \texttt{-- TRACE 1 stop -> tail-recursion}.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
0001  IST          1
0002  JMP      2 => 0004
0004  KSHORT   2   0
0005  ISGE     2   0
0006  JMP      2 => 0011
0007  UGET     2   0; factorial
0008  SUBVN    3   0   0  ; 1
0009  MULVV    4   0   1
0010  CALLT    2   3
0000  FUNCF    5 ; Ex.lua:3
0001  IST          1
0002  JMP      2 => 0004
0004  KSHORT   2   0
0005  ISGE     2   0
0006  JMP      2 => 0011
0007  UGET     2   0 ; factorial
0008  SUBVN    3   0   0  ; 1
0009  MULVV    4   0   1
0010  CALLT    2   3
0000  FUNCF    5 ; Ex.lua:3
0001  IST          1
0002  JMP      2 => 0004
0004  KSHORT   2   0
0005  ISGE     2   0
0006  JMP      2 => 0011
0007  UGET     2   0 ; factorial
0008  SUBVN    3   0   0  ; 1
0009  MULVV    4   0   1
0010  CALLT    2   3
0000  FUNCF    5 ; Ex.lua:3
---- TRACE 1 stop -> tail-recursion
\end{lstlisting}
\end{multicols}

\noindent
The fact that the compiler transform tail-recursive functions in loops is more explicit in the IR (see the \texttt{-- LOOP --} label at line \texttt{0014}).

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
---- TRACE 1 IR
0001 >  num SLOAD  #2    T
0002 >  num SLOAD  #1    T
0003 >  num GT     0002  +0  
0004    fun SLOAD  #0    R
0005 >  fun EQ     0004  Ex.lua:3
0006    num SUB    0002  +1  
0007    num MUL    0002  0001
0008 >  num GT     0006  +0  
0009    num SUB    0006  +1  
0010    num MUL    0007  0006
0011 >  num GT     0009  +0  
0012  + num SUB    0009  +1  
0013  + num MUL    0010  0009
0014 ------ LOOP ------------
0015 >  num GT     0012  +0  
0016    num SUB    0012  +1  
0017    num MUL    0013  0012
0018 >  num GT     0016  +0  
0019    num SUB    0016  +1  
0020    num MUL    0017  0016
0021 >  num GT     0019  +0  
0022  + num SUB    0019  +1  
0023  + num MUL    0020  0019
0024    num PHI    0013  0023
0025    num PHI    0012  0022
---- TRACE 1 stop -> tail-recursion
\end{lstlisting}
\end{multicols}