\chapter{Side traces and Stitch traces}
\label{chapter:side-stitch-traces}

The aim of this chapter is to show some concrete experimental cases in order to understand how multiple traces are generated and organised by LuaJIT. Multiple traces appear when there is a branch in the control flow and more than one path is frequently executed. In this case, LuaJIT will create a root trace with \textit{side traces}\textit{} attached to it.

Another important aspect that will be explored is \textit{stitch traces}. It is a mechanism that avoids trace aborts due to Not-Yet-Implemented (NYI) functions when encountering a C function or  not-compiled built-in.

Before to investigate these aspects, we will present canonical transformations of logical expressions, loops equivalence and asserts. These structures create branches in the code that can be represented by simple if-statements and for loops. This is the reason why in the second part of this chapter we only will consider if-statements and for loops to investigate how LuaJIT creates \textit{side traces} and \textit{stitch trace}.

Concerning \textit{side traces}, we will first clarifies how the just-in-time compiler (JIT) generate traces from simple loops. Then we will analyse how traces are connected with each other in more complex structures. Finally, we will investigates recursive functions. For each case it is described how the compiler behaves and it is shown: the LUA code of the example; the corresponding bytecode and intermediate representation (IR) generated; a flow diagram that refers to the IR.

\section{Canonical transformations}
This section aims to analyse the traces generated by LuaJIT for logical expressions and their corresponding if-statements transformation. Then, it will present the equivalence between possible loop structures in Lua and how they are mapped to traces by the JIT compiler. Finally, it will explore the JIT behaviour when dealing with asserts.

\subsection{Logical transformations}
\subsubsection{Lua logical operators}
Before to introduce how LuaJIT generate traces when dealing with logical expression, we must clarify the rationale behind logical operators in Lua. Here we propose again the explanation taken from the reference manual \cite{lua-ref-man}.

The logical operators in Lua are \texttt{and}, \texttt{or}, and \texttt{not}. Like the control structures, all logical operators consider both \texttt{false} and \texttt{nil} as \texttt{false} and anything else as \texttt{true}. 

The negation operator \texttt{not} always returns \texttt{false} or \texttt{true}. The conjunction operator \texttt{and} returns its first argument if this value is \texttt{false} or \texttt{nil}; otherwise, and returns its second argument. The disjunction operator \texttt{or} returns its first argument if this value is different from \texttt{nil} and \texttt{false}; otherwise, or returns its second argument. Both \texttt{and} and \texttt{or} use short-cut evaluation; that is, the second operand is evaluated only if necessary.

\subsubsection{Trace creation with logical operators}
As explained in the previous chapters LuaJIT generates traces from recording the executed bytecode instructions of hotpaths (either hotloop or hotfunctions). The high-level structure of the Lua code plays a key role to determine which bytecode instructions are executed because it determines which branch of the control flow is taken. 

\begin{center}
    {\textit{The rationale applied by LuaJIT in generating traces from standards control structures (e.g. if-statements) is exactly the same when dealing with logical operators.}}
\end{center}

\noindent
Once understood the JIT behaviour for hotpaths which contain control structures (e.g. if-statements) you can apply the same rationale to logical operators because every expressions with logical operators can be transformed to the corresponding if-statement expressions.

In this section we present the canonical transformation of logical operators in the corresponding if-statements expressions. We illustrate concrete examples of the logical operators \texttt{and} and \texttt{or} considering all the possible combinations of the operands values (\texttt{true}, \texttt{false}, \texttt{nil}).



\subsubsection{And}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- And

local a, b, c = v1, v2, nil -- v1, v2 in (true, false, nil)

for i=1,100 do
 	c = a and b
end
\end{lstlisting}
\end{mdframed}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- And with if-statement

local a, b, c = v1, v2, nil -- v1, v2 in (true, false, nil)

for i=1,100 do
 	if a then c = b else c = a end
end
\end{lstlisting}
\end{mdframed}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \texttt{c} & \texttt{a} & \texttt{b} \\
        \hline
        \texttt{  2  } & \texttt{  1  } & \texttt{  2  } \\
        \texttt{false} & \texttt{  1  } & \texttt{false} \\
        \texttt{ nil } & \texttt{  1  } & \texttt{ nil } \\
        \texttt{false} & \texttt{false} & \texttt{  2  } \\
        \texttt{false} & \texttt{false} & \texttt{false} \\
        \texttt{false} & \texttt{false} & \texttt{ nil } \\
        \texttt{ nil } & \texttt{ nil } & \texttt{  2  } \\
        \texttt{ nil } & \texttt{ nil } & \texttt{false} \\
        \texttt{ nil } & \texttt{ nil } & \texttt{ nil } \\
        \hline
    \end{tabular}
    \caption{Operands values of \texttt{c = a and b}}
    \label{tab:and-transformation}
\end{table}



\subsubsection{Or}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Or

local a, b, c = v1, v2, nil -- v1, v2 in (true, false, nil)

for i=1,100 do
 	c = a or b
end
\end{lstlisting}
\end{mdframed}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Or with if-statement

local a, b, c = v1, v2, nil -- v1, v2 in (true, false, nil)

for i=1,100 do
 	if a then c = a else c = b end
end
\end{lstlisting}
\end{mdframed}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \texttt{c} & \texttt{a} & \texttt{b} \\
        \hline
        \texttt{  1  } & \texttt{  1   } & \texttt{  2  } \\
        \texttt{  1  } & \texttt{  1   } & \texttt{false} \\
        \texttt{  1  } & \texttt{  1   } & \texttt{ nil } \\
        \texttt{  2  } & \texttt{false } & \texttt{  2  } \\
        \texttt{false} & \texttt{false } & \texttt{false} \\
        \texttt{ nil } & \texttt{false } & \texttt{ nil } \\
        \texttt{  2  } & \texttt{ nil  } & \texttt{  2  } \\
        \texttt{false} & \texttt{ nil  } & \texttt{false} \\
        \texttt{ nil } & \texttt{ nil  } & \texttt{ nil } \\
        \hline
    \end{tabular}
    \caption{Operands values of \texttt{c = a or b}}
    \label{tab:or-transformation}
\end{table}



\subsubsection{And-Or}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- And-Or

local a, b, c, d = v1, v2, v3, nil -- v1, v2, v3 in (true, false, nil)

for i=1,100 do
 	d = a and b or c
end
\end{lstlisting}
\end{mdframed}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- And-Or with if statements

local a, b, c, d = v1, v2, v3, nil -- v1, v2, v3 in (true, false, nil)

for i=1,100 do
 	if a then
		if b then d = b else d = c end
	else
		d = c
	end
end
\end{lstlisting}
\end{mdframed}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        \texttt{d} & \texttt{a}  & \texttt{b}  & \texttt{c}  \\
        \hline
		\texttt{  2  } & \texttt{  1  } & \texttt{  2  } & \texttt{  3   } \\
		\texttt{  2  } & \texttt{  1  } & \texttt{  2  } & \texttt{false } \\
		\texttt{  2  } & \texttt{  1  } & \texttt{  2  } & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{  1  } & \texttt{false} & \texttt{  3   } \\
		\texttt{false} & \texttt{  1  } & \texttt{false} & \texttt{false } \\
		\texttt{ nil } & \texttt{  1  } & \texttt{false} & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{  1  } & \texttt{ nil } & \texttt{  3   } \\
		\texttt{false} & \texttt{  1  } & \texttt{ nil } & \texttt{false } \\
		\texttt{ nil } & \texttt{  1  } & \texttt{ nil } & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{false} & \texttt{  2  } & \texttt{  3   } \\
		\texttt{false} & \texttt{false} & \texttt{  2  } & \texttt{false } \\
		\texttt{ nil } & \texttt{false} & \texttt{  2  } & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{false} & \texttt{false} & \texttt{  3   } \\
		\texttt{false} & \texttt{false} & \texttt{false} & \texttt{false } \\
		\texttt{ nil } & \texttt{false} & \texttt{false} & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{false} & \texttt{ nil } & \texttt{  3   } \\
		\texttt{false} & \texttt{false} & \texttt{ nil } & \texttt{false } \\
		\texttt{ nil } & \texttt{false} & \texttt{ nil } & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{ nil } & \texttt{  2  } & \texttt{  3   } \\
		\texttt{false} & \texttt{ nil } & \texttt{  2  } & \texttt{false } \\
		\texttt{ nil } & \texttt{ nil } & \texttt{  2  } & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{ nil } & \texttt{false} & \texttt{  3   } \\
		\texttt{false} & \texttt{ nil } & \texttt{false} & \texttt{false } \\
		\texttt{ nil } & \texttt{ nil } & \texttt{false} & \texttt{ nil  } \\
		\texttt{  3  } & \texttt{ nil } & \texttt{ nil } & \texttt{  3   } \\
		\texttt{false} & \texttt{ nil } & \texttt{ nil } & \texttt{false } \\
		\texttt{ nil } & \texttt{ nil } & \texttt{ nil } & \texttt{ nil  } \\
        \hline
    \end{tabular}
    \caption{Operands values of \texttt{d = a and b or c}}
    \label{tab:and-or-transformation}
\end{table}



\subsubsection{Or-And}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Or-And

local a, b, c, d = v1, v2, v3, nil -- v1, v2, v3 in (true, false, nil)

for i=1,100 do
 	d = a or b and c
end
\end{lstlisting}
\end{mdframed}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Or-And with if statements

local a, b, c, d = v1, v2, v3, nil -- v1, v2, v3 in (true, false, nil)

for i=1,100 do
    if a then d = a
    elseif b then d = c
    else d = b end
end
\end{lstlisting}
\end{mdframed}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        \texttt{d} & \texttt{a}  & \texttt{b}  & \texttt{c}  \\
        \hline
		\texttt{  1  } & \texttt{  1  } & \texttt{  2  } & \texttt{  3  } \\
		\texttt{  1  } & \texttt{  1  } & \texttt{  2  } & \texttt{false} \\
		\texttt{  1  } & \texttt{  1  } & \texttt{  2  } & \texttt{ nil } \\
		\texttt{  1  } & \texttt{  1  } & \texttt{false} & \texttt{  3  } \\
		\texttt{  1  } & \texttt{  1  } & \texttt{false} & \texttt{false} \\
		\texttt{  1  } & \texttt{  1  } & \texttt{false} & \texttt{ nil } \\
		\texttt{  1  } & \texttt{  1  } & \texttt{ nil } & \texttt{  3  } \\
		\texttt{  1  } & \texttt{  1  } & \texttt{ nil } & \texttt{false} \\
		\texttt{  1  } & \texttt{  1  } & \texttt{ nil } & \texttt{ nil } \\
		\texttt{  3  } & \texttt{false} & \texttt{  2  } & \texttt{  3  } \\
		\texttt{false} & \texttt{false} & \texttt{  2  } & \texttt{false} \\
		\texttt{ nil } & \texttt{false} & \texttt{  2  } & \texttt{ nil } \\
		\texttt{false} & \texttt{false} & \texttt{false} & \texttt{  3  } \\
		\texttt{false} & \texttt{false} & \texttt{false} & \texttt{false} \\
		\texttt{false} & \texttt{false} & \texttt{false} & \texttt{ nil } \\
		\texttt{ nil } & \texttt{false} & \texttt{ nil } & \texttt{  3  } \\
		\texttt{ nil } & \texttt{false} & \texttt{ nil } & \texttt{false} \\
		\texttt{ nil } & \texttt{false} & \texttt{ nil } & \texttt{ nil } \\
		\texttt{  3  } & \texttt{ nil } & \texttt{  2  } & \texttt{  3  } \\
		\texttt{false} & \texttt{ nil } & \texttt{  2  } & \texttt{false} \\
		\texttt{ nil } & \texttt{ nil } & \texttt{  2  } & \texttt{ nil } \\
		\texttt{false} & \texttt{ nil } & \texttt{false} & \texttt{  3  } \\
		\texttt{false} & \texttt{ nil } & \texttt{false} & \texttt{false} \\
		\texttt{false} & \texttt{ nil } & \texttt{false} & \texttt{ nil } \\
		\texttt{ nil } & \texttt{ nil } & \texttt{ nil } & \texttt{  3  } \\
		\texttt{ nil } & \texttt{ nil } & \texttt{ nil } & \texttt{false} \\
		\texttt{ nil } & \texttt{ nil } & \texttt{ nil } & \texttt{ nil } \\
        \hline
    \end{tabular}
    \caption{Operands values of \texttt{d = a or b and c}}
    \label{tab:or-and-transformation}
\end{table}





\subsubsection{And with function}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- And with function

local a,b = v1, nil -- v1 in (1, 2, 3, false, nil)

local function f(a)
	if a == 1 then return true
	elseif a == 2 then return false
	else return nil end
end

for i=1,100 do
	b = a and f(a) or nil
end
\end{lstlisting}
\end{mdframed}

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- And with function if-statements

local a,b = v1, nil -- v1 in (1, 2, 3, false, nil)

local function f(a)
	if a == 1 then return true
	elseif a == 2 then return false
	else return nil end
end

for i=1,100 do
	if a then
		local tmp = f(a)
		if tmp then b = tmp else b = nil end
	else
		b = nil
	end
end
\end{lstlisting}
\end{mdframed}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|}
        \hline
        \texttt{b} & \texttt{a}  & \texttt{f(a)}  & \texttt{nil}  \\
        \hline
		\texttt{true} & \texttt{  1  } & \texttt{true } & \texttt{nil} \\
		\texttt{nil } & \texttt{  2  } & \texttt{false} & \texttt{nil} \\
		\texttt{nil } & \texttt{  3  } & \texttt{ nil } & \texttt{nil} \\
		\texttt{nil } & \texttt{false} & \texttt{  -  } & \texttt{nil} \\
		\texttt{nil } & \texttt{ nil } & \texttt{  -  } & \texttt{nil} \\
        \hline
    \end{tabular}
    \caption{Operands values of \texttt{b = a and f(a) or nil}}
    \label{tab:and-function-transformation}
\end{table}



\newpage

\subsection{Loops equivalence}
In this section we present the equivalence between different loop structures in Lua and how they are handled by LuaJIT when compiling a trace. For each example we show the recorded bytecode instructions and the IR (the details of the syntax will be explained in the next section). When investigating the equivalence between code structures we must especially focus on the IR because it will be directly mapped to the compiled machine code.
\subsubsection{Numeric for loop}
The numeric \texttt{for} loop is the most simple and intuitive way to define a loop in Lua.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Numeric for loop

local x = 0

for i=1,100 do
 	x = x + 11
end
\end{lstlisting}
\end{mdframed}
\noindent The recorded bytecode instructions are the following.
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   0  ; 11
0007  FORL     1 => 0006
---- TRACE 1 stop -> loop
\end{lstlisting}
\noindent Looking at the IR you can notice that the index variable \texttt{i} is considered by LuaJIT as an integer value (line \texttt{0001}).
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003  + num ADD    0002  +11 
0004  + int ADD    0001  +1  
0005 >  int LE     0004  +100
0006 ------ LOOP ------------
0007  + num ADD    0003  +11 
0008  + int ADD    0004  +1  
0009 >  int LE     0008  +100
0010    int PHI    0004  0008
0011    num PHI    0003  0007
---- TRACE 1 stop -> loop
\end{lstlisting}
\end{multicols}




\subsubsection{While loop}
The same loop previously presented can be realised by a \texttt{while} structure. 
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- While loop

local x, i = 0, 1

while i <= 100 do
	x = x + 11
	i = i + 1
end
\end{lstlisting}
\end{mdframed}
\noindent The recorded bytecode instructions are the following.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0007  ADDVN    0   0   0  ; 11
0008  ADDVN    1   1   1  ; 1
0009  JMP      2 => 0003
0003  KSHORT   2 100
0004  ISGT     1   2
0005  JMP      2 => 0010
0006  LOOP     2 => 0010
---- TRACE 1 stop -> loop
\end{lstlisting}
\end{multicols}
\noindent In this case the index variable \texttt{i} is considered as a numeric value in the IR (line \texttt{0001}) because it can be changed by the user at any time in the loop body.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0001 >  num SLOAD  #1    T
0002  + num ADD    0001  +11 
0003 >  num SLOAD  #2    T
0004  + num ADD    0003  +1  
0005 >  num LE     0004  +100
0006 ------ LOOP ------------
0007  + num ADD    0002  +11 
0008  + num ADD    0004  +1  
0009 >  num LE     0008  +100
0010    num PHI    0002  0007
0011    num PHI    0004  0008
---- TRACE 1 stop -> loop
\end{lstlisting}
\end{multicols}

\subsubsection{Repeat until loop}
The \texttt{repeat until} structure is equivalent to the onces previously presented, but the first iteration of the loop is always executed. From the point of view of the JIT this does not change the result (in terms of generated traces) because a loop is recorded only if its iteration frequency exceeds a certain threshold.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Repeat until loop

local x, i = 0, 1

repeat
	x = x + 11
	i = i + 1
until i > 100
\end{lstlisting}
\end{mdframed}
\noindent The recorded bytecode instructions are the following.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0004  ADDVN    0   0   0  ; 11
0005  ADDVN    1   1   1  ; 1
0006  KSHORT   2 100
0007  ISGE     2   1
0008  JMP      2 => 0003
0003  LOOP     2 => 0009
---- TRACE 1 stop -> loop
\end{lstlisting}
\end{multicols}
\noindent The IR is identical to the \texttt{while} structure with the only difference that the end-condition of the loop is \texttt{i$>$100} (either than \texttt{i$\le$100}). The IR instruction is \texttt{ISGE} "is grater than" at line \texttt{0007}. This is because the loop repeats until the given condition becomes true.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0001 >  num SLOAD  #1    T
0002  + num ADD    0001  +11 
0003 >  num SLOAD  #2    T
0004  + num ADD    0003  +1  
0005 >  num ULE    0004  +100
0006 ------ LOOP ------------
0007  + num ADD    0002  +11 
0008  + num ADD    0004  +1  
0009 >  num ULE    0008  +100
0010    num PHI    0002  0007
0011    num PHI    0004  0008
---- TRACE 1 stop -> loop

\end{lstlisting}
\end{multicols}

\subsubsection{Generic for loop}
Generic \texttt{for} is a Lua structure that allows you to traverse all values returned by an iterator function. Its syntax is the following.

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
for vars... in iter,state,ctl do body end
\end{lstlisting}
\end{mdframed}
\noindent
A generic loop cannot be compiled if the iterator uses the built-in function \texttt{next()} (e.g. \texttt{pairs()}) because LuaJIT does not support the compilation of \texttt{next()}. In fact, recording aborts if \texttt{next()} is executed because it belongs to the Not-Yet-implemented features of the JIT compiler.

On the other hand, a generic loop not based on \texttt{next()} (e.g. \texttt{ipairs()}) can be compiled. Here we propose an example.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Ipairs loop

local x, array = 0, {}
for i=1,100 do array[i] = i end

for i,v in ipairs(array) do
	x = x + v + 11	
end
\end{lstlisting}
\end{mdframed}
\noindent The recorded bytecode instructions are the following. Note that \texttt{TRACE 1} is not shown, but it simply refers to the numeric loop at line 4.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 2 start Ex.lua:6
0013  ADDVV    7   0   6
0014  ADDVN    0   7   0  ; 11
0015  ITERC    5   3   3
0000  . FUNCC           ; ipairs_aux
0016  ITERL    5 => 0013
---- TRACE 2 stop -> loop
\end{lstlisting}
\end{multicols}
\noindent The overall IR is similar to the other loop structures previously presented. The main differences consists of handling the table. The end-condition of the loop is represented by the \texttt{ABC} instruction (Array Bounds Check: bound $>$ index) at lines \texttt{0012}, \texttt{0021}.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 2 start Ex.lua:6
---- TRACE 2 IR
0001 >  num SLOAD  #1    T
0002 >  num SLOAD  #7    T
0003    num ADD    0002  0001
0004  + num ADD    0003  +11 
0005 >  fun SLOAD  #3    T
0006 >  tab SLOAD  #4    T
0007 >  num SLOAD  #5    T
0008 >  fun EQ     0005  ipairs_aux
0009    int CONV   0007  int.num
0010  + int ADD    0009  +1  
0011    int FLOAD  0006  tab.asize
0012 >  int ABC    0011  0010
0013    p32 FLOAD  0006  tab.array
0014    p32 AREF   0013  0010
0015 >+ num ALOAD  0014
0016 ------ LOOP ------------
0017    num ADD    0015  0004
0018  + num ADD    0017  +11 
0019    num CONV   0010  num.int
0020  + int ADD    0010  +1  
0021 >  int ABC    0011  0020
0022    p32 AREF   0013  0020
0023 >+ num ALOAD  0022
0024    num PHI    0004  0018
0025    num PHI    0015  0023
0026    int PHI    0010  0020
---- TRACE 2 stop -> loop
\end{lstlisting}
\end{multicols}

\begin{comment}
\begin{multicols}{2}
\noindent
\textbf{Prerequisites}\\
To read this chapter you are supposed to know: what is a tracing JIT; the mechanism of traces and side traces; what are intermediate representation (IR) and bytecode (see Chapter \ref{}).

\columnbreak
\noindent
\textbf{What you want to learn}\\
After reading this chapter you will learn how LuaJIT creates traces and how they are connected to each other.
\end{multicols}
\end{comment}

\subsection{Assert}
An assert in Lua is treated by LuaJIT as a "standard" if-statement condition. The example below shows a case were the assert becomes false after 100 iteration of the loop. 
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Assert

local assert = assert 

for i=1,200 do
	assert(i<100, "Case failed: expected i<100 but got instead.")
end
\end{lstlisting}
\end{mdframed}

\noindent
In this case the JIT will create a trace with a guard condition on '\texttt{i<100}' (line \texttt{0003}, \texttt{0008} in the IR), which verifies that its value is less than 100. The details of the syntax of the IR are explained from the next paragraph. 

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #3    CI
0002 >  fun SLOAD  #2    T
0003 >  int LT     0001  +100
0004 >  fun EQ     0002  assert
0005  + int ADD    0001  +1  
0006 >  int LE     0005  +200
0007 ------ LOOP ------------
0008 >  int LT     0005  +100
0009  + int ADD    0005  +1  
0010 >  int LE     0009  +200
0011    int PHI    0005  0009
---- TRACE 1 stop -> loop
\end{lstlisting}
\end{multicols}

\section{Essential cases}
This section illustrates how the compiler creates traces in simple but significant cases: (i) empty loop, (ii) loop with assignment, (iii) loop with if-statement and (iv) nested loop.

\subsection{Empty loop}
Even an empty loop can generate a trace. When the loop becomes hot, the virtual machine (VM) starts to record the instructions and the types of their operands during execution. Thus, it generates the equivalent IR. 

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Empty loop
for i=1,100 do

end
\end{lstlisting}
\end{mdframed}

\noindent
In this case the bytecode produced contains just the \texttt{FORL} loop instruction.

\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
0005  FORL     0 => 0005
---- TRACE 1 stop -> loop
\end{lstlisting}

\noindent
On the other hand, the IR holds more interesting information because it shows the fact that the first iteration of the loop is unrolled.

\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
---- TRACE 1 IR
0001    int SLOAD  #1    CI
0002  + int ADD    0001  +1  
0003 >  int LE     0002  +100
0004 ------ LOOP ------------
0005  + int ADD    0002  +1  
0006 >  int LE     0005  +100
0007    int PHI    0002  0005
---- TRACE 1 stop -> loop
\end{lstlisting}

\noindent
The instruction at the first line \texttt{SLOAD} (stack slot load) is used to init the variable \textit{i} used by the loop where its left operand \#1 refers to the first variable slot and the right operand contains two flags: coalesce (C) and inherited (I).

The next lines are supposed to contain the loop, but the same instructions are repeated twice. This is due to the fact that the first iteration of the loop is unrolled (lines \texttt{0002-0003}), then the actual loop (lines \texttt{0005-0006}) is shown after the \texttt{-- LOOP --} label (line \texttt{0004}). The first iteration ensures that pre-conditions for all subsequent instructions are met. \texttt{ADD} increments the loop counter \textit{i} and \texttt{LE} (left operand $\leq$ right operand) checks that its value is lower than 100. If this condition is not satisfied ($i>100$), the execution takes the trace exit at line \texttt{0003} or at line \texttt{0006}. Possible exits from the trace are indicated by the symbol $>$ in the second column of the instruction. If the condition is true ($i\leq100$) the execution flow makes a backward jump to the \texttt{-- LOOP --} label (line \texttt{0004}) and continues with the next iteration of the loop. It is important to highlight the fact that only the instructions at lines \texttt{0005-0006} are executed repeatedly.

Eventually, the \texttt{PHI} instruction positioned at the end of the looping trace (line \texttt{0007}) allows to select values from different incoming path at control flow merge points \cite{SSA-form}. The left operand \texttt{0002} holds a reference to the initial value of \textit{i}, the right operand \texttt{0005} holds a reference to the value after each loop iteration. Operands of the PHI function are indicated by the symbol + in the second column of the IR (in this case lines \texttt{0002} and \texttt{0005}).

The diagram below explains the execution flows of the IR in a cleaner way. Specially for the next complex examples it will be easier to look at the diagram  to understand the IR.

% Diagram
\begin{figure}[H]
\hspace*{3cm}
\vspace*{-2.5cm}
\begin{tikzpicture}

%Nodes
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#1 \\
        i $\leftarrow$ i + 1\\
        ? i$\le$100};
\myblocknode{1}{0005} (node1) [below=of node0] (node1) [below=of node0]
        {i $\leftarrow$ i + 1\\
        ? i$\le$100};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};


% Lines TRACE 1
\draw[->] (init) -- (node0) ;
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1.south) .. controls +(down:40mm) and +(left:28mm) .. (node1.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};

%Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) ]{};
\node[label=\mylooplabel{0004}, frame_loop,fit= (node1)]{};

%Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) ]{};
\node[label=\mylooplabel{0004}, frame_loop,fit= (node1)]{};


\end{tikzpicture}
\caption{Trace flow diagram empty loop}
\label{fig:trace-empty}
\end{figure}

\noindent
\begin{comment}
Explaining the IR in details would be to complex and tedious for the reader. Thus, from this example forward there will be a diagram that explains the execution  flows.  
\end{comment}
In the diagrams each trace is divided into blocks containing instructions with a unique identifier enclosed in squared brackets (e.g. \texttt{[0]}). On the top right of each block it is indicated the line in the IR of the first instruction in the block (e.g. \texttt{0001}). At the end of each block there could be a conditional expression that represents a guard. In the case that the guard is violated (the condition is false) the trace is exited, otherwise the execution continues to the next block of the trace. Possible exits are represented by the letter 'X' followed by their number (e.g. X1). By default an exit leads to the virtual machine. Note that when the execution flow exits from a trace, values on stack slots are restored.

\subsection{Loop with assignment}
This example has been designed to analyse what happens if the loop contains variable assignments. It will be shown that the compiler is able to move invariant instructions out of loops\footnote{Conversation on the LuaJIT mailing list: 
\texttt{https://www.freelists.org/post/luajit/\\how-to-understand-the-structure-of-irmcode-dump,1}} with the loop-invariant code motion (LICM) optimisation. Another small difference from the previous example is that the maximum loop counter is not a literal but it is a variable ($N=100$). 
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with assignment

local x = 0
local y = 0
local N = 100

for i=1,N do
	 y = 11
	 x = x + 22
end
\end{lstlisting}
\end{mdframed}

\noindent
As shown in the bytecode below, the instruction \texttt{KSHORT} (line \texttt{0008}) sets \textit{y} to 11 and \texttt{ADDVN} (line \texttt{0009}) computes the operation $x=x+22$. Here it is clear that at bytecode level the LICM optimisation is not applied because the execution flow makes a backward jump to line \texttt{0008} and $y=11$ is repeated at each iteration of the loop. In fact, no optimisation is performed by LuaJIT on bytecode.

\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
0008  KSHORT   1  11
0009  ADDVN    0   0   0  ; 22
0010  FORL     3 => 0008
---- TRACE 1 stop -> loop
\end{lstlisting}

\noindent
It should be noted that the initialisation of variable values are performed outside traces because these instruction are not executed repeatedly, but they are executed just once. 

In the IR below it is possible to see more details of what really occurs.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
---- TRACE 1 IR
0001 >  int SLOAD  #5    CRI
0002 >  int LE     0001  +2147483646
0003    int SLOAD  #4    CI
0004 >  num SLOAD  #1    T
0005  + num ADD    0004  +22 
0006  + int ADD    0003  +1  
0007 >  int LE     0006  0001
0008 ------ LOOP ------------
0009  + num ADD    0005  +22 
0010  + int ADD    0006  +1  
0011 >  int LE     0010  0001
0012    int PHI    0006  0010
0013    num PHI    0005  0009
---- TRACE 1 stop -> loop
\end{lstlisting}
\end{multicols} 

\noindent
The first two lines refer to the maximum loop counter \textit{N}: \texttt{SLOAD} (line \texttt{0001}) with flag read-only (R) is used to init \textit{N} and in line \texttt{0002} it is checked if its value falls into the signed 32-bit integer range ($N\leq+2147483646$). In this way, the compiler can discriminate if the loop will be done over integer or floating point values. The \texttt{SLOAD}s at lines \texttt{0003}-\texttt{0004} are used to init the variables \textit{i} and \textit{x} respectively. In particular \textit{x} has a flag of type check (T).

At IR level it is possible to see compiler optimisations. The value of \textit{x} changes at each iteration of the loop. Thus, the \texttt{ADD} instruction $x=x+22$ is contained both in the pre-loop (line \texttt{0005}) and in the actual loop (line \texttt{0009}). On the other hand, the expression $y=11$ can be moved outside the body of the loop by LICM without affecting the semantics of the program. This instruction will be executed only once outside the trace (in fact there is no line in the IR referring to it).

At the end of the dump there are two \texttt{PHI} functions. The first (line \texttt{0012}) refers to the variable \textit{i} as explained in the previous example. The second (line \texttt{0013}) refers to the variable \textit{x} and it is necessary for the same reason.

The graph below shows what was just explained.

% Diagram
\begin{figure}[H]
\hspace*{+3.5cm}
\vspace*{-2.5cm}
\begin{tikzpicture}

%Nodes
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { N $\leftarrow$ \#5 \\
        ? N:const};
\myblocknode{1}{0002} (node1) [below=of node0] (node1) [below=of node0]   
        {? N:int};
\myblocknode{2}{0003} (node2) [below=of node1]            
        {i $\leftarrow$ \#4\\
        x $\leftarrow$ \#1\\
        ? x:num};
\myblocknode{3}{0005} (node3) [below=of node2]   
        {x $\leftarrow$ x + 22\\
        i $\leftarrow$ i + 1\\
        ? i$\le$N};
\myblocknode{4}{0009} (node4) [below=of node3]             
        {x $\leftarrow$ x + 22\\
        i $\leftarrow$ i + 1\\
        ? i$\le$N};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};



% Lines TRACE 1
\draw[->] (init) -- (node0) ;
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4.south) .. controls +(down:40mm) and +(left:28mm) .. (node4.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};


%Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) (node2) (node3) (node4)]{};8\node[label=\mylooplabel{0008}, frame_loop,fit= (node4)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with assignment}
\label{fig:trace-loop-assignment}
\end{figure}


\subsection{Loop with if-statements}
\label{subsec:if-statement}
In this example the goal is to investigate how the compiler creates traces when an if-statement is contained inside a loop.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with if-statement

local x = 0

for i=1,1e4 do
	x = x + 11
	if i%10 == 0 then   -- if-statement
		x = x + 22
	end
	x = x + 33
end
\end{lstlisting}
\end{mdframed}
In the loop shown above, the execution flow skips most of the times the instruction contained in the if-statement because the expression $i\%10==0$ is true only every 10 iterations of the loop. From $i=0$ forward, the instructions that are executed repeatedly the most are $x=x+11$ and $x=x+33$, thus the compiler creates a trace containing these instructions (\texttt{TRACE 1}). By increasing \textit{i}, the condition of the if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction within the if-statement and what follows down to the loop "end".
 
 
 %% comment
 \begin{comment}
and when the loop becomes hot, the compiler generates a trace (TRACE 1) that contains all the instructions in the loop, but the one inside the if-statement. This happens because this set of instruction is executed repeatedly.

Later on, every time that is \textit{i} is multiple of 10, the instruction inside the if-statement is executed. This means that the same exit from the root trace (TRACE 1) is taken more and more frequently. Then, when this happens for enough times (as said before the default threshold is 56) the compiler generate a side trace (TRACE 2). It should be noted that the side trace contains both the instruction inside the if-statement $x=x+22$ and the next instruction $x=x+33$. 
 \end{comment}
The bytecode below shows more in details this method (these are the bytecode instructions recorded by the JIT). 
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   0  ; 11
0007  MODVN    5   4   1  ; 10
0008  ISNEN    5   2      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   4  ; 33
0012  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
0010  ADDVN    0   0   3  ; 22
0011  ADDVN    0   0   4  ; 33
0012  JFORL    1   1
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The expression $x=x+11$ is computed at line \texttt{0006}. Then in line \texttt{0007} it is calculated $i\%10$ and in line \texttt{0008} it is checked that the result is not equal to zero. If the condition is true the execution flow jumps to the instruction at line \texttt{0011} where $x=x+33$ is computed and then line \texttt{0012} contains the loop backward branch. If the condition is false ($i\%10 = 0$) the \texttt{JMP} to 0011 is not taken. The execution flow goes from the instruction at line \texttt{0009} to the very next instruction at line \texttt{0010}. In fact, this is the link between the root trace (\texttt{TRACE 1}) and the side trace (\texttt{TRACE 2}). Finally, in the side trace both the \texttt{ADD} operations $x=x+22$ and $x=x+33$ are executed. To conclude the execution flow goes back to the parent trace \texttt{-- TRACE 2 stop -> 1}.

The IR follows the same logic. What changes is the fact that the first iteration of the loop is unrolled. Moreover, in the IR it is more clear how the two traces are connected to each other. At the very first line of the side trace \texttt{-- TRACE 2 start 1/4} the number 1 refers to the parent trace and 4 to the exit number that corresponds to line \texttt{0012} in \texttt{TRACE 1}. Line \texttt{0012} is the exit number 4, which is the 4th line having as second column the symbol $>$ in \texttt{TRACE 1}.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +10 
0005 >  int NE     0004  +0  
0006  + num ADD    0003  +33 
0007  + int ADD    0001  +1  
0008 >  int LE     0007  +10000
0009 ------ LOOP ------------
0010    num ADD    0006  +11 
0011    int MOD    0007  +10 
0012 >  int NE     0011  +0  
0013  + num ADD    0010  +33 
0014  + int ADD    0007  +1  
0015 >  int LE     0014  +10000
0016    int PHI    0007  0014
0017    num PHI    0006  0013
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +10000
0007    num CONV   0005  num.int
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The diagram in Fig. \ref{fig:trace-if} shows the IR flow diagram for this example. \texttt{TRACE 1} is organised as follow: blocks \texttt{[0]},\texttt{[1]},\texttt{[2]} contain the first pass of the unrolled loop; blocks \texttt{[3]},\texttt{[4]} contain the \textit{n-1} iterations of the actual loop; in block \texttt{[3]} there is a possible exit that leads to the side trace. At the end, when \texttt{TRACE 2} is finished, the execution flow joins \texttt{TRACE 1} in block \texttt{[0]}, while other exits join the VM.

\begin{comment}
Possible side exits are indicated by the symbol $>$ in the IR dump. The number of the exit is related with the order in which it appears in the IR (e.g. the first $>$ symbol at line 0002 refers to the exit 1).
\end{comment}

% Diagram
\begin{figure}[H]
\hspace*{+1cm}
\vspace*{0cm}
\begin{tikzpicture}

%Nodes
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0] (node1) [below=of node0]   
            {x $\leftarrow$ x + 11\\                                    
            ? i\%10 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]            
            {x $\leftarrow$ x + 33\\
            i $\leftarrow$ i + 1\\
            ? i$\le$1e4};
\myblocknode{3}{0010} (node3) [below=of node2]   
            {x $\leftarrow$ x + 11\\
            ? i\%10 $\neq$ 0};
\myblocknode{4}{0013} (node4) [below=of node3]             
            {x $\leftarrow$ x + 33\\
            i $\leftarrow$ i + 1\\
            ? i$\le$1e4};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};


% Nodes TRACE 2
\myblocknode{5}{0001} (node5) [right=1.5cm of exit3]             
        {x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{6}{0004} (node6) [below=of node5]             
        {x $\leftarrow$ x + 33\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e4};
\node[emptynode] (exit6) [right=of node6] {X1};
\node[emptynode] (alias_trace1) [below=of node6] {[0]};

% Lines TRACE 1
\draw[->] (init) -- (node0) ;
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4.west) .. controls +(left:20mm) and +(left:20mm) .. (node3.west) node[near start , shift={(0.9,-0.1)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};

% Lines TRACE 2
\draw[->] (exit4.east) .. controls +(right:10mm) and +(left:10mm) .. (node5.west);
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node6) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (alias_trace1) node[near start, right] {\tiny{T}};

%Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) (node2) (node3) (node4)]{};
\node[label=TRACE 2, frame,fit=(node5) (node6)]{};
\node[label=\mylooplabel{0009}, frame_loop,fit= (node3) (node4)]{};


\end{tikzpicture}
\caption{Trace flow diagram loop with if-statement}
\label{fig:trace-if}
\end{figure}



%%%%%%%%%%%%%%%%%%%%%%%%% comment %%%%%%%%%%%
\begin{comment}
In Lines 0003-0008 contain the loop unrolled and lines 00010-0015 the actual loop. It is performed the modulus operation (MOD), it is checked that its result is not equal to zero (NE), then the loop is incremented (ADD) and  it is checked the loop termination (LE).


As it is shown in the dump here there are  two traces: the original root trace (TRACE 1) and a new trace (TRACE 2) called side trace. This is necessary because there is a branch (if-statement) in the code and traces are not allowed to have internal branches. The root trace will internally handle the case when the loop index is not multiple of 10 but it will exit to the side trace otherwise. The side trace then rejoins the root trace as is written in the dump \texttt{---- TRACE 2 stop -> 1}. The effect is that the loop alternates between saying inside the root trace and exiting to the side trace. Line 0005 contains a guard indicated by the symbol $>$ that is a possible exit from the trace.

TRACE 2:

The first two lines of TRACE 2 are simple init of the registers. Lines 0003-0009 take the reference and load \textit{x}. Then, in line 0010 it is executed $x=x+1$ and the result is stored (line 0011). Finally the loop is incremented (line 0012) and it is checked the loop termination (line 0013). The last line 0014 converts the number in integer.\\
\texttt{Ref. https://github.com/lukego/blog/issues/}\\
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%% end comment %%%%%%%%%%%

\subsection{Nested loop}
\label{subsec:nested-loop}
This section explains how the compiler generates traces in the case of nested loop. It creates a trace that refers to the inner loop  and another trace for the outer loop.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Nested loop

local x = 0

for i=1,1e4,2 do    -- outer loop
    x = x + 11
    for j=2,1e3,4 do    -- inner loop
        x = x + 22
    end
    x = x + 33
end
\end{lstlisting}
\end{mdframed}

\noindent
The instructions of the inner loop will be executed repeatedly at first. Thus, the inner loop becomes hot first and the compiler creates a trace (\texttt{TRACE 1}). At some point, also the outer loop becomes hot and the compiler generates another trace (\texttt{TRACE 2}) that is a side trace of the previous one.

Traces are organised in a reverse order if compared with the standard way of thinking the execution flow of nested loops. As it is shown in the bytecode below: \texttt{TRACE 1} (inner loop) contains the instruction $x=x+22$;  \texttt{TRACE 2} (outer loop) contains first the instruction $x=x+33$ and then $x=x+11$. Moreover, \texttt{TRACE 2} is a side trace that starts at the exit number 3 of \texttt{TRACE 1} (when the inner loop finished).

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
0011  ADDVN    0   0   1  ; 22
0012  FORL     5 => 0011
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/3 Ex.lua:10
0013  ADDVN    0   0   2  ; 33
0014  FORL     1 => 0006
0006  ADDVN    0   0   0  ; 11
0007  KSHORT   5   2
0008  KSHORT   6 1000
0009  KSHORT   7   4
0010  JFORI    5 => 0013
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The method of organising traces for nested loops is more clear when looking at the IR and the diagram.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:7
---- TRACE 1 IR
0001    int SLOAD  #6    CI
0002 >  num SLOAD  #1    T
0003  + num ADD    0002  +22 
0004  + int ADD    0001  +4  
0005 >  int LE     0004  +1000
0006 ------ LOOP ------------
0007  + num ADD    0003  +22 
0008  + int ADD    0004  +4  
0009 >  int LE     0008  +1000
0010    int PHI    0004  0008
0011    num PHI    0003  0007
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/3 Ex.lua:10
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    num ADD    0001  +33 
0003    num SLOAD  #2    I
0004    num ADD    0003  +2  
0005 >  num LE     0004  +10000
0006    num ADD    0002  +11 
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

% Diagram
\begin{figure}[H]
\hspace*{0cm}
\vspace*{-2cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        {i $\leftarrow$ \#6 \\
         x $\leftarrow$ \#1 \\
         ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]   
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$1e3};
\myblocknode{2}{0007} (node2) [below=of node1]            
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$1e3};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};

% Nodes TRACE 2
\myblocknode{3}{0001} (node3) [right=1.5cm of exit2]
        {x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 33\\
        i $\leftarrow$ \#2 \\
        i $\leftarrow$ i + 2\\
        ? i$\le$1e4};
\myblocknode{4}{0006} (node4) [below=of node3]             
        {x $\leftarrow$ x + 11};
\node[emptynode] (exit4) [right=of node3] {X1};
\node[emptynode] (alias_trace1) [below=of node4] {[0]};

%Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2.south) .. controls +(down:40mm) and +(left:28mm) .. (node2.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};

% Lines TRACE 2
\draw[->] (exit3.east) .. controls +(right:10mm) and +(left:10mm) .. (node3.west);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (alias_trace1);

%Frames
\node[label=TRACE 1 ,frame,fit=(node0) (node1) (node2)] (trace1) {};
\node[label=TRACE 2 ,frame,fit=(node3) (node4)] (trace2) {};
\node[label=\mylooplabel{0006}, frame_loop,fit= (node2)]{};
\end{tikzpicture}
\caption{Trace flow diagram nested loop}
\end{figure}
\begin{comment}
TRACE 1 contains the instruction of the inner loop. At line 0001 SLOAD (store a value) is used to init the register used by the loop. Lines 0002-0008 take the reference and load \textit{x}. Lines 0009-0012 contain the loop unrolled and lines 0014-0017 the actual loop. The value of x is incremented by 1 (ADD) and the result is stored (HSTORE), then the loop is incremented (ADD) and  it is checked the loop termination (LE). Then, in line 0010 it is executed $x=x+1$ and the result is stored (line 0011). Finally the loop is incremented (line 0012) and it is checked the loop termination (line 0013). The last line 0014 converts the number in integer.

In TRACE 2 it is shown the instruction related to the outer loop. In this case is computed the operation $x=x*3$ (line 0011). The other lines show instruction previously described.\\

\end{comment}
\noindent
The outer loop (\texttt{TRACE 2}) goes around the inner loop (\texttt{TRACE 1}) and joins it in block \texttt{[0]}.

On the other hand, if the inner loop had low iteration count, it would be unrolled and inlined\footnote{Conversation on the LuaJIT mailing list: 
\texttt{https://www.freelists.org/post/luajit/\\How-does-LuaJITs-trace-compiler-work,1}}.

\newpage

\section{Loop with two if-statements}
\label{section:2-if-statements}

In this section it will be explored how the JIT-compiler organises traces when there are two different if-statements within the same loop. The cases investigated are as follow: (i) the first if-statement condition becomes true (hot) before the second; (ii) the second becomes true (hot) before the first; (iii) the if-statement conditions become true (hot) at different time; (iv) the if-statement conditions become true (hot) at the same time.

\subsection{Case 1}
\label{2-if-example1}
This example shows how traces are organised in a loop with 2 if-statements when the first condition becomes true (hot) before the second. In this case the truthfulness of the second if-condition implies the first.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement Example 1

local x = 0

for i=1,1e6 do
	x = x + 11
	if i%10 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
	if i%20 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}
As it happened in the example \ref{subsec:if-statement}, the execution flow skips most of the times the instructions contained in the if-statements and the compiler creates a trace (\texttt{TRACE 1}) with the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of the first if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction within the first if-statement $x=x+22$ and what follows down to the loop "end". At some point, also the condition of the second if-statement becomes true repeatedly, thus the compiler creates a trace (\texttt{TRACE 3}) with the instruction within the second if-statement $x=x+44$ and what follows down to the loop "end".
% comment
\begin{comment}
The side exit that corresponds to the first if-statement is taken more often than the second. Thus, the first side trace to be generated (TRACE 2) refers to the first if-statement. Then, when the side exit that corresponds to the second side trace is taken enough times, another side trace will be created (TRACE 3). It should be noted that in this case TRACE 3 is a side trace of TRACE 2, while TRACE 2 is a side trace of TRACE 1.
The code above generates the following bytecode dump. TRACE 1 contains all the instructions, but the ones inside the if-statements (lines 7 and 11); TRACE 2 the instructions inside the first if-statement and what follows; TRACE 3 the instructions inside the second if-statement and what follows.
\end{comment}

The bytecode below shows what was just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 10
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1

---- TRACE 3 start 2/1 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
Links between traces are more explicit in the IR and in the diagram.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +10 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007    int MOD    0001  +20 
0008 >  int NE     0007  +0  
0009  + num ADD    0006  +55 
0010  + int ADD    0001  +1  
0011 >  int LE     0010  +1000000
0012 ------ LOOP ------------
0013    num ADD    0009  +11 
0014    int MOD    0010  +10 
0015 >  int NE     0014  +0  
0016    num ADD    0013  +33 
0017    int MOD    0010  +20 
0018 >  int NE     0017  +0  
0019  + num ADD    0016  +55 
0020  + int ADD    0010  +1  
0021 >  int LE     0020  +1000000
0022    int PHI    0010  0020
0023    num PHI    0009  0019
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +20 
0006 >  int NE     0005  +0  
0007    num ADD    0004  +55 
0008    int ADD    0002  +1  
0009 >  int LE     0008  +1000000
0010    num CONV   0008  num.int
---- TRACE 2 stop -> 1

---- TRACE 3 start 2/1 Ex.lua:12
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
Generally side traces are created when an exit is taken repeatedly. In this case \texttt{TRACE 2} starts at the exit number 5 of \texttt{TRACE 1} (line \texttt{0015}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 3} starts at the exit number 1 of \texttt{TRACE 2} (line \texttt{0006}) and it joins \texttt{TRACE 1} at the end. Thus, \texttt{TRACE 2} is a side trace of \texttt{TRACE 1} and \texttt{TRACE 3} is a side trace of \texttt{TRACE 2}, both joining \texttt{TRACE 1} at their ends. 
% Diagram
\begin{figure}[H]
\hspace*{-1cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{3}{0009} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0013} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{5}{0016} (node5) [below=of node4]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{6}{0019} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit6) [right=of node5] {X6};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right=of exit4]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node9] {X2};
\node[emptynode] (alias1_trace1) [below=of node9] {[0]};

% Nodes TRACE 3
\myblocknode{10}{0001} (node10) [right=of exit1_trace2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{11}{0004} (node11) [below=of node10]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace3) [right=of node11] {X1};
\node[emptynode] (alias2_trace1) [below=of node11] {[0]};
    
% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:10mm) and +(left:12mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit1_trace2) -- (node10);
\draw[->] (node10) -- (node11);
\draw[->] (node11) -- (exit1_trace3) node[near start, above] {\tiny{F}};
\draw[->] (node11) -- (alias2_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0012}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,fit=(node7) (node8) (node9)]{};
\node[label=TRACE 3, frame,fit=(node10) (node11)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 1}
\end{figure}

\newpage

\subsection{Case 2}
\label{2-if-example2}
This example is the same as the previous one, but the order of the two if-statement is reversed. In particular, it investigates how traces are organised in a loop with two if-statements when the second condition  becomes true (hot) before the first. In  this case the truthfulness of the first if-condition implies the second. 

Even if the change from the previous example is small, it causes a big difference in the traces organisation.
% comment The second if-statement generates a side trace before the first because the condition \texttt{i\%10==0} becomes true twice more than \texttt{i\%20==0} (again this is due the fact that 20 is multiple of 10). The side exit that corresponds to the second if-statement is taken more times than the first. Thus, the first side trace to be generated (TRACE 2) refers to the second if-statement. Then, when the side exit that corresponds to the second side trace is taken for enough times, another side trace will be created (TRACE 3). It should be noted that the structure is completely different from Example \ref{2-if-example1} because both TRACE 3 and TRACE 2 are side traces of TRACE 1.

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement Example 2

local x = 0

for i=1,1e6 do
	x = x + 11
	if i%20 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
	if i%10 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}

\noindent
The compiler creates the first trace (\texttt{TRACE 1}) with the same logic of the previous example. It contains the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of the second if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 3}) that contains the instruction within the second if-statement $x=x+44$ and what follows. At some point, also the condition of the first if-statement becomes true repeatedly, thus the compiler creates a trace (\texttt{TRACE 2}) that contains instructions within both the if-statements and what follows.
%The code above generates the following bytecode dump. TRACE 1 contains all the instructions, but the ones inside the if-statements; TRACE 2 the instructions inside the second if-statement and what follows; TRACE 3 the instructions inside both the if-statements and what follows.

The bytecode below shows what was just explained.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 20
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}
%In the IR it is possible to see the side traces chain of calls.  TRACE 2 starts at the exit number 5 of TRACE 1 (line 0015) and it joins TRACE 1 at the end.  TRACE 3 starts at the exit number 6 of TRACE 1 (line 0018) and it joins TRACE 1 at the end.

\noindent
The IR displayed below shows that \texttt{TRACE 2} starts at the exit number 5 of \texttt{TRACE 1} (line \texttt{0015}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 3} starts at the exit number 6 of \texttt{TRACE 1} (line \texttt{0018}) and it joins \texttt{TRACE 1} at the end. Thus, both \texttt{TRACE 2} and \texttt{TRACE 3} are side traces of  \texttt{TRACE 1}.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +20 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007    int MOD    0001  +10 
0008 >  int NE     0007  +0  
0009  + num ADD    0006  +55 
0010  + int ADD    0001  +1  
0011 >  int LE     0010  +1000000
0012 ------ LOOP ------------
0013    num ADD    0009  +11 
0014    int MOD    0010  +20 
0015 >  int NE     0014  +0  
0016    num ADD    0013  +33 
0017    int MOD    0010  +10 
0018 >  int NE     0017  +0  
0019  + num ADD    0016  +55 
0020  + int ADD    0010  +1  
0021 >  int LE     0020  +1000000
0022    int PHI    0010  0020
0023    num PHI    0009  0019
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +10 
0006 >  int EQ     0005  +0  
0007    num ADD    0004  +44 
0008    num ADD    0007  +55 
0009    int ADD    0002  +1  
0010 >  int LE     0009  +1000000
0011    num CONV   0009  num.int
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 3 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
It is possible to make a comparison between this example and the previous one. 

In the example of case 1, LuaJIT creates a longer chain of traces attached one to another in a sequence of sidetraces. The root trace (\texttt{TRACE 1}), which covers the most critical hotpath, contains only one guard that is actually failing when the if-conditions are true. 

On the other hand, in the example of case 2 all the sidetraces are attached to the root trace (\texttt{TRACE 1}), hence there is no chain. The root trace, which covers the most critical hotpath, contains both the two guards that are actually failing.

% Diagram
\begin{figure}[H]
\hspace*{+1cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{3}{0009} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0013} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{5}{0016} (node5) [below=of node4]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{6}{0019} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit6) [right=of node5] {X6};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right=of exit1]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%10 = 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 44};
\myblocknode{10}{0009} (node10) [below=of node9]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};

\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node10] {X2};
\node[emptynode] (alias1_trace1) [below=of node10] {[0]};

% Nodes TRACE 3
\myblocknode{11}{0001} (node11) [right=of exit6]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{12}{0004} (node12) [below=of node11]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace3) [right=of node12] {X1};
\node[emptynode] (alias2_trace1) [below=of node12] {[0]};
    
% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:10mm) and +(left:12mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node9) -- (node10);
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit6) -- (node11);
\draw[->] (node11) -- (node12);
\draw[->] (node12) -- (exit1_trace3) node[near start, above] {\tiny{F}};
\draw[->] (node12) -- (alias2_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0012}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,fit=(node7) (node8) (node9) (node10)]{};
\node[label=TRACE 3, frame,fit=(node11) (node12)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 2}
\end{figure}

\newpage

\subsection{Case 3}
\label{2-if-example3}
This example shows how traces are organised in a loop with two if-statements when both conditions become true (hot) at the same time. The compiler does not generate a side trace for each if-statement, but it creates only a unique side trace. In this case the truthfulness of the first if-condition implies the second and vice versa.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement  Example 3

local x = 0

for i=1,1e6 do
	x = x + 11
	if i%10 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
	if i%10 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}
The compiler produces the first trace (\texttt{TRACE 1}) with the same logic of the previous examples. It contains the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of both if-statements becomes true at the same time more and more often. Thus, the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction with both if-statements and what follows.

The bytecode below shows what was just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 10
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   2  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   7  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   2  ; 10
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0015  ADDVN    0   0   6  ; 44
0016  ADDVN    0   0   7  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
In the IR below it is shown that \texttt{TRACE 2} starts at the exit number 4 of \texttt{TRACE 1} (line \texttt{0013}) and it joins \texttt{TRACE 1} at the end. The exit of \texttt{TRACE 2} at \texttt{line 0006} will never be taken because $i\%10 = 0$ will always be true, since this was the condition that led the execution flow to enter in the side trace itself (see Diagram \ref{fig:2-if-ex3}).

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +10 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007  + num ADD    0006  +55 
0008  + int ADD    0001  +1  
0009 >  int LE     0008  +1000000
0010 ------ LOOP ------------
0011    num ADD    0007  +11 
0012    int MOD    0008  +10 
0013 >  int NE     0012  +0  
0014    num ADD    0011  +33 
0015  + num ADD    0014  +55 
0016  + int ADD    0008  +1  
0017 >  int LE     0016  +1000000
0018    int PHI    0008  0016
0019    num PHI    0007  0015
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/4 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +10 
0006 >  int EQ     0005  +0  
0007    num ADD    0004  +44 
0008    num ADD    0007  +55 
0009    int ADD    0002  +1  
0010 >  int LE     0009  +1000000
0011    num CONV   0009  num.int
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}

% Diagram
\begin{figure}[H]
\hspace*{+1cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33};
\myblocknode{3}{0007} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0011} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%10 $\neq$ 0};
\myblocknode{5}{0014} (node5) [below=of node4]
        {x $\leftarrow$ x + 33};
\myblocknode{6}{0015} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right =3cm of node2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%10 = 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 44};
\myblocknode{10}{0008} (node10) [below=of node9]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};

\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node10] {X2};
\node[emptynode] (alias1_trace1) [below=of node10] {[0]};

    
% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6);
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}]  {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:10mm) and +(left:12mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node9) -- (node10) node[near start, right] {\tiny{T}};
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0010}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,inner sep=5mm, fit=(node7) (node8) (node9) (node10)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 3}
\label{fig:2-if-ex3}
\end{figure}

\newpage

\subsection{Case 4}
\label{2-if-example4}
This example shows how traces are organised in a loop with two if-statements when the first condition becomes hot before the second, but the  conditions become true mostly at different time. In this case the  truthfulness of the second implies the first just for some iteration of the loop (e.g. $i = 60, 120, ...$).

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Loop with 2 if-statement Example 4

local x = 0

for i=1,1e6 do
	x = x + 11
	if i%15 == 0 then   -- 1st if-statement
		x = x + 22
	end
	x = x + 33
	if i%20 == 0 then   -- 2nd if-statement
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}

\noindent
The compiler creates the first trace (\texttt{TRACE 1}) with the same logic of the previous examples. It contains the instructions $x=x+11$, $x=x+33$, $x=x+55$. By increasing \textit{i}, the condition of the first if-statement becomes true more and more often, thus the compiler will generate a side trace (\texttt{TRACE 2}) that contains the instruction within the first if-statement $x=x+22$ and what follows. At some point, also the condition of the second if-statement becomes true repeatedly, thus the compiler creates a trace (\texttt{TRACE 3}) with the instruction within the second if-statement $x=x+44$ and what follows. Both \texttt{TRACE 2} and \texttt{TRACE 3} are side trace of \texttt{TRACE 1}.
 
 Later on, when both the conditions becomes true at the same time repeatedly, the compiler generates another trace (\texttt{TRACE 4}) that contains the instruction within the second if-statement $x=x+44$ and what follows. \texttt{TRACE 4} starts as a side trace of \texttt{TRACE 2}.

The bytecode below shows what was just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   1  ; 11
0007  MODVN    5   4   2  ; 15
0008  ISNEN    5   3      ; 0
0009  JMP      5 => 0011
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  FORL     1 => 0006
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
0010  ADDVN    0   0   4  ; 22
0011  ADDVN    0   0   5  ; 33
0012  MODVN    5   4   6  ; 20
0013  ISNEN    5   3      ; 0
0014  JMP      5 => 0016
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 3 stop -> 1

---- TRACE 4 start 2/1 Ex.lua:12
0015  ADDVN    0   0   7  ; 44
0016  ADDVN    0   0   8  ; 55
0017  JFORL    1   1
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The IR displayed below shows that \texttt{TRACE 2} starts at the exit number 5 of \texttt{TRACE 1} (line \texttt{0015}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 3} starts at the exit number 6 of \texttt{TRACE 1} (line \texttt{0018}) and it joins \texttt{TRACE 1} at the end. \texttt{TRACE 4} starts at the exit number 1 of \texttt{TRACE 2} (line \texttt{0006}) and it joins \texttt{TRACE 1} at the end. 


\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    int MOD    0001  +15 
0005 >  int NE     0004  +0  
0006    num ADD    0003  +33 
0007    int MOD    0001  +20 
0008 >  int NE     0007  +0  
0009  + num ADD    0006  +55 
0010  + int ADD    0001  +1  
0011 >  int LE     0010  +1000000
0012 ------ LOOP ------------
0013    num ADD    0009  +11 
0014    int MOD    0010  +15 
0015 >  int NE     0014  +0  
0016    num ADD    0013  +33 
0017    int MOD    0010  +20 
0018 >  int NE     0017  +0  
0019  + num ADD    0016  +55 
0020  + int ADD    0010  +1  
0021 >  int LE     0020  +1000000
0022    int PHI    0010  0020
0023    num PHI    0009  0019
---- TRACE 1 stop -> loop

---- TRACE 2 start 1/5 Ex.lua:8
---- TRACE 2 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +22 
0004    num ADD    0003  +33 
0005    int MOD    0002  +20 
0006 >  int NE     0005  +0  
0007    num ADD    0004  +55 
0008    int ADD    0002  +1  
0009 >  int LE     0008  +1000000
0010    num CONV   0008  num.int
---- TRACE 2 stop -> 1

---- TRACE 3 start 1/6 Ex.lua:12
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 3 stop -> 1

---- TRACE 4 start 2/1 Ex.lua:12
---- TRACE 4 IR
0001    num SLOAD  #1    PI
0002    int SLOAD  #2    PI
0003    num ADD    0001  +44 
0004    num ADD    0003  +55 
0005    int ADD    0002  +1  
0006 >  int LE     0005  +1000000
0007    num CONV   0005  num.int
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
Possible trace paths covered by the execution flow are: (i) \texttt{TRACE 1}: if both conditions are false; (ii) \texttt{TRACE 1}, \texttt{TRACE 2}: if the first condition is true and the second is false; (iii) \texttt{TRACE 1}, \texttt{TRACE 3}: if the first condition is false and the second is true; (iv) \texttt{TRACE 1}, \texttt{TRACE 2}, \texttt{TRACE 4}: if both conditions are true.

% Diagram
\begin{figure}[H]
\hspace*{-0.5cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#2 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{2}{0006} (node2) [below=of node1]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{3}{0009} (node3) [below=of node2]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\myblocknode{4}{0013} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 11\\
        ? i\%20 $\neq$ 0};
\myblocknode{5}{0016} (node5) [below=of node4]
        {x $\leftarrow$ x + 33\\
        ? i\%10 $\neq$ 0};
\myblocknode{6}{0019} (node6)[below=of node5]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
       ? i$\le$1e6};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};
\node[emptynode] (exit4) [right=of node3] {X4};
\node[emptynode] (exit5) [right=of node4] {X5};
\node[emptynode] (exit6) [right=of node5] {X6};
\node[emptynode] (exit7) [right=of node6] {X7};

% Nodes TRACE 2
\myblocknode{7}{0001} (node7) [right=of exit2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\x $\leftarrow$ x + 22};
\myblocknode{8}{0004} (node8) [below=of node7]
        {x $\leftarrow$ x + 33\\
        ? i\%20 $\neq$ 0};
\myblocknode{9}{0007} (node9) [below=of node8]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace2) [right=of node8] {X1};
\node[emptynode] (exit2_trace2) [right=of node9] {X2};
\node[emptynode] (alias1_trace1) [below=of node9] {[0]};

% Nodes TRACE 3
\myblocknode{10}{0001} (node10) [right=of exit6]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{11}{0004} (node11) [below=of node10]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace3) [right=of node11] {X1};
\node[emptynode] (alias2_trace1) [below=of node11] {[0]};
    
% Nodes TRACE 4
\myblocknode{12}{0001} (node12) [right=of exit1_trace2]
        { x $\leftarrow$ \#1 \\
        i $\leftarrow$ \#2 \\
        x $\leftarrow$ x + 44};
\myblocknode{13}{0004} (node13) [below=of node12]
        {x $\leftarrow$ x + 55\\
        i $\leftarrow$ i + 1\\
        ? i$\le$1e6};
\node[emptynode] (exit1_trace4) [right=of node13] {X1};
\node[emptynode] (alias3_trace1) [below=of node13] {[0]};
    

% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node2) -- (node3) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node5) -- (node6) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node3) -- (exit4) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit5) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit6) node[near start, above] {\tiny{F}};
\draw[->] (node6) -- (exit7) node[near start, above] {\tiny{F}};
\draw[->] (node6.west) .. controls +(left:20mm) and +(left:20mm) .. (node4.west) node[near start , shift={(0.9,-0.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (exit5.east) .. controls +(right:15mm) and +(left:12mm) .. (node7.west);
\draw[->] (node7) -- (node8);
\draw[->] (node8) -- (node9) node[near start, right] {\tiny{T}};
\draw[->] (node8) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node9) -- (alias1_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit6) -- (node10);
\draw[->] (node10) -- (node11);
\draw[->] (node11) -- (exit1_trace3) node[near start, above] {\tiny{F}};
\draw[->] (node11) -- (alias2_trace1) node[near start, right] {\tiny{T}};

% Lines TRACE 4
\draw[->] (exit1_trace2) -- (node12);
\draw[->] (node12) -- (node13);
\draw[->] (node13) -- (exit1_trace4) node[near start, above] {\tiny{F}};
\draw[->] (node13) -- (alias3_trace1) node[near start, right] {\tiny{T}};

% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) (node3) (node4) (node5) (node6)]{};
\node[label=\mylooplabel{0012}, frame_loop,fit= (node4) (node5) (node6)]{};
\node[label=TRACE 2, frame,fit=(node7) (node8) (node9) (node9)]{};
\node[label=TRACE 3, frame,fit=(node10) (node11)]{};
\node[label=TRACE 4, frame,fit=(node12) (node13)]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 if-statements Example 4}
\label{fig:2if-exemple4}
\end{figure}

\section{Nested loop with more inner loops}
\label{section:2-inner-loops}

The goal of this example is to explain how the compiler organises traces in the case of nested loop with two (or more) inner loops. The compiler generates: a trace for each inner loop, a trace (or more) to connect them
and a trace for the outer loop that goes around the inner loops.

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Nested loop with 2 inner loops

local x = 0

for i=1,1e4,2 do        -- outer loop
	x = x + 11
	for j=3,2e4,4 do    -- inner loop (LOOP 1)
		x = x + 22
	end
	x = x + 33
	for k=5,3e4,6 do    -- inner loop (LOOP 2)
		x = x + 44
	end
	x = x + 55
end
\end{lstlisting}
\end{mdframed}

\noindent
In this case the instructions of the inner loops will be executed repeatedly at first. Thus, the inner loops become hot first and the compiler creates a trace for each of them (\texttt{TRACE 1}, \texttt{TRACE 2}). At some point, also the outer loop becomes hot and the compiler generates a trace (\texttt{TRACE 3}) to connect the two inner loops (with the instruction $x=x+33$) and a trace (\texttt{TRACE 4}) that goes around the inner loops (with the instructions $x=x+55$, $x=x+11$). Note that \texttt{TRACE 1}, \texttt{TRACE 2} are root traces and \texttt{TRACE 3}, \texttt{TRACE 4} are sidetraces.

The bytecode below shows what was just explained.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start *.lua:7
0011  ADDVN    0   0   1  ; 22
0012  FORL     5 => 0011
---- TRACE 1 stop -> loop

---- TRACE 2 start *.lua:11
0018  ADDVN    0   0   3  ; 44
0019  FORL     5 => 0018
---- TRACE 2 stop -> loop

---- TRACE 3 start 1/3 *.lua:10
0013  ADDVN    0   0   2  ; 33
0014  KSHORT   5   5
0015  KSHORT   6 30000
0016  KSHORT   7   6
0017  JFORI    5 => 0020
---- TRACE 3 stop -> 2

---- TRACE 4 start 2/3 *.lua:14
0020  ADDVN    0   0   4  ; 55
0021  FORL     1 => 0006
0006  ADDVN    0   0   0  ; 11
0007  KSHORT   5   3
0008  KSHORT   6 20000
0009  KSHORT   7   4
0010  JFORI    5 => 0013
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

\noindent
The IR shows the details of the traces organisation. \texttt{TRACE 1} and \texttt{TRACE 2} are independent traces. \texttt{TRACE 3} starts at the exit number 3 of \texttt{TRACE 1} (line \texttt{0009}) and it joins \texttt{TRACE 2} at the end (this is the connection of the two inner loops). \texttt{TRACE 4} starts at the exit number 3 of \texttt{TRACE 2} (line \texttt{0009}) and it joins \texttt{TRACE 1} at the end. This is the part of the outer loop that goes around the inner loops.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start *.lua:7
---- TRACE 1 IR
0001    int SLOAD  #6    CI
0002 >  num SLOAD  #1    T
0003  + num ADD    0002  +22 
0004  + int ADD    0001  +4  
0005 >  int LE     0004  +20000
0006 ------ LOOP ------------
0007  + num ADD    0003  +22 
0008  + int ADD    0004  +4  
0009 >  int LE     0008  +20000
0010    int PHI    0004  0008
0011    num PHI    0003  0007
---- TRACE 1 stop -> loop

---- TRACE 2 start *.lua:11
---- TRACE 2 IR
0001    int SLOAD  #6    CI
0002 >  num SLOAD  #1    T
0003  + num ADD    0002  +44 
0004  + int ADD    0001  +6  
0005 >  int LE     0004  +30000
0006 ------ LOOP ------------
0007  + num ADD    0003  +44 
0008  + int ADD    0004  +6  
0009 >  int LE     0008  +30000
0010    int PHI    0004  0008
0011    num PHI    0003  0007
---- TRACE 2 stop -> loop

---- TRACE 3 start 1/3 *.lua:10
---- TRACE 3 IR
0001    num SLOAD  #1    PI
0002    num ADD    0001  +33 
---- TRACE 3 stop -> 2

---- TRACE 4 start 2/3 *.lua:14
---- TRACE 4 IR
0001    num SLOAD  #1    PI
0002    num ADD    0001  +55 
0003    num SLOAD  #2    I
0004    num ADD    0003  +2  
0005 >  num LE     0004  +10000
0006    num ADD    0002  +11 
---- TRACE 4 stop -> 1
\end{lstlisting}
\end{multicols}

% Diagram
\begin{figure}[H]
\hspace*{-2.7cm}
\vspace*{0cm}
\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{0001} (node0) [right=of init]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{0003} (node1) [below=of node0]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$2e4};
\myblocknode{2}{0007} (node2) [below=of node1]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 4\\
        ? j$\le$2e4};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};


% Nodes TRACE 2
\myblocknode{3}{0001} (node3) [right=3.8cm of exit1]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{4}{0003} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 6\\
        ? k$\le$3e4};
\myblocknode{5}{0007} (node5) [below=of node4]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 6\\
        ? k$\le$3e4};
\node[emptynode] (exit1_trace2) [right=of node3] {X1};
\node[emptynode] (exit2_trace2) [right=of node4] {X2};
\node[emptynode] (exit3_trace2) [right=of node5] {X3};

% Nodes TRACE 3
\myblocknode{6}{0001} (node6)[below right=3cm and 0cm of exit3]
        { x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 33};
    
% Nodes TRACE 4
\myblocknode{7}{0001} (node7)[below right=3cm and 0cm of exit3_trace2]
        { x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 55\\
        i $\leftarrow$ \#2 \\
        i $\leftarrow$ i + 2\\
        ? i$\le$1e4};
\myblocknode{8}{0006} (node8)[below=of node7]
        {  x $\leftarrow$ x + 11};
\node[emptynode] (exit1_trace4) [right=of node7] {X1};
\node[emptynode] (alias1_trace1) [below=of node8] {[0]};

    
% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node2.south) .. controls +(down:40mm) and +(left:28mm) .. (node2.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 2
\draw[->] (node6.east) .. controls +(right:10mm) and +(left:25mm) .. (node3.west);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit3_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5.south) .. controls +(down:40mm) and +(left:28mm) .. (node5.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 3
\draw[->] (exit3.south) .. controls +(down:20mm) and +(left:5mm) .. (node6.west);

% Lines TRACE 4
\draw[->] (exit3_trace2.south) .. controls +(down:20mm) and +(left:5mm) .. (node7.west);
\draw[->] (node7) -- (node8) node[near start, right] {\tiny{T}};
\draw[->] (node7) -- (exit1_trace4) node[near start, above] {\tiny{F}};
\draw[->] (node8) -- (alias1_trace1);




% Frames
\node[label=TRACE 1,frame,fit= (node0) (node1) (node2) ]{};
\node[label=TRACE 2, frame,fit=(node3) (node4) (node5)]{};
\node[label=TRACE 3, frame,fit=(node6)]{};
\node[label=TRACE 4, frame,fit=(node7) (node8)]{};
\node[label={[shift={(-1,0)}]LOOP 1}, frame_loop,fit= (node2) ]{};
\node[label={[shift={(-1,0)}]LOOP 2}, frame_loop,fit= (node5) ]{};

\end{tikzpicture}
\caption{Trace flow diagram loop with 2 inner loops}
\label{fig:2-inner-loops}
\end{figure}

\noindent
The same structure is maintained when the number of inner loops increases. If \textit{n} is the number of inner loops, the compiler generates: \textit{n} traces for the \textit{n} inner loops, $n-1$ traces to connect the inner loops and a final trace for the outer loop that goes around the inner loops.

The code below describes the case of $n=3$.

\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Nested loop with 3 inner loops

local x = 0

for i=1,1e4 do          -- outer loop
	x = x + 11
    for j=1,2e4,2 do    -- inner loop (LOOP 1)
		x = x + 22
	end
	x = x + 33
    for k=1,3e4,3 do    -- inner loop (LOOP 2)
		x = x + 44 
	end
	x = x + 55
    for t=1,4e4,4 do    -- inner loop (LOOP 3)
		x = x + 66
	end
	x = x + 77 
end
\end{lstlisting}
\end{mdframed}

% Diagram
% This diagram comes from copy paste of the previous one. The number of traces and block do not correspond to the one you see in the diagram:
% TRACE 1 -> TRACE 1; TRACE 2 -> TRACE 5; TRACE 3 -> TRACE 2; TRACE 4 -> TRACE 3; TRACE 5 -> TRACE 6; TRACE 6 -> TRACE 4 
\begin{figure}[H]
\begin{adjustwidth}{-2.8cm}{0cm}

\resizebox{18cm}{10cm}{

\begin{tikzpicture}

% Nodes TRACE 1
\node[emptynode] (init) {};
\myblocknode{0}{*} (node0) [right=of init]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{1}{*} (node1) [below=of node0]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 2\\
        ? j$\le$2e4};
\myblocknode{2}{*} (node2) [below=of node1]
        {x $\leftarrow$ x + 22\\
        j $\leftarrow$ j + 2\\
        ? j$\le$2e4};
\node[emptynode] (exit1) [right=of node0] {X1};
\node[emptynode] (exit2) [right=of node1] {X2};
\node[emptynode] (exit3) [right=of node2] {X3};

% Nodes TRACE 2 (old TRACE 5)
\node[emptynode] (init) {};
\myblocknode{3}{*} (node9) [right=3.8cm of exit1]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{4}{*} (node10) [below=of node9]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 3\\
        ? k$\le$3e4};
\myblocknode{5}{*} (node11) [below=of node10]
        {x $\leftarrow$ x + 44\\
        k $\leftarrow$ k + 3\\
        ? k$\le$3e4};
\node[emptynode] (exit1_trace5) [right=of node9] {X1};
\node[emptynode] (exit2_trace5) [right=of node10] {X2};
\node[emptynode] (exit3_trace5) [right=of node11] {X3};

% Nodes TRACE 3 (old TRACE 2)
\myblocknode{6}{*} (node3) [right=3.8cm of exit1_trace5]
        { i $\leftarrow$ \#6 \\
        x $\leftarrow$ \#1 \\
        ? x:num};
\myblocknode{7}{*} (node4)
        [below=of node3]
        {x $\leftarrow$ x + 66\\
        t $\leftarrow$ t + 4\\
        ? t$\le$4e4};
\myblocknode{8}{*} (node5) [below=of node4]
        {x $\leftarrow$ x + 66\\
        t $\leftarrow$ t + 4\\
        ? t$\le$4e4};
\node[emptynode] (exit1_trace2) [right=of node3] {X1};
\node[emptynode] (exit2_trace2) [right=of node4] {X2};
\node[emptynode] (exit3_trace2) [right=of node5] {X3};


% Nodes TRACE 4 (old TRACE 3)
\myblocknode{9}{*} (node6)[below right=3cm and 0cm of exit3]
        {x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 33};
        
% Nodes TRACE 5 (old TRACE 6)
\myblocknode{10}{*} (node12)[below right=3cm and 0cm of exit3_trace5]
        {x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 55};
    
% Nodes TRACE 6 (old TRACE 4)
\myblocknode{11}{*} (node7)[below right=3cm and 0cm of exit3_trace2]
        { x $\leftarrow$ \#1 \\
        x $\leftarrow$ x + 77\\
        i $\leftarrow$ \#2 \\
        i $\leftarrow$ i + 2\\
        ? i$\le$1e4};
\myblocknode{12}{*} (node8)[below=of node7]
        {x $\leftarrow$ x + 11};
\node[emptynode] (exit1_trace4) [right=of node7] {X1};
\node[emptynode] (alias1_trace1) [below=of node8] {[0]};

% Lines TRACE 1
\draw[->] (init) -- (node0);
\draw[->] (node0) -- (node1) node[near start, right] {\tiny{T}};
\draw[->] (node1) -- (node2) node[near start, right] {\tiny{T}};
\draw[->] (node0) -- (exit1) node[near start, above] {\tiny{F}};
\draw[->] (node1) -- (exit2) node[near start, above] {\tiny{F}};
\draw[->] (node2) -- (exit3) node[near start, above] {\tiny{F}};
\draw[->] (node2.south) .. controls +(down:40mm) and +(left:28mm) .. (node2.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 2 (old TRACE 5) 
\draw[->] (node6.east) .. controls +(right:10mm) and +(left:25mm) .. (node9.west);
\draw[->] (node9) -- (node10) node[near start, right] {\tiny{T}};
\draw[->] (node10) -- (node11) node[near start, right] {\tiny{T}};
\draw[->] (node9) -- (exit1_trace5) node[near start, above] {\tiny{F}};
\draw[->] (node10) -- (exit2_trace5) node[near start, above] {\tiny{F}};
\draw[->] (node11) -- (exit3_trace5) node[near start, above] {\tiny{F}};
\draw[->] (node11.south) .. controls +(down:40mm) and +(left:28mm) .. (node11.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 3 (old TRACE 2)
\draw[->] (node12.east) .. controls +(right:10mm) and +(left:25mm) .. (node3.west);
\draw[->] (node3) -- (node4) node[near start, right] {\tiny{T}};
\draw[->] (node4) -- (node5) node[near start, right] {\tiny{T}};
\draw[->] (node3) -- (exit1_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node4) -- (exit2_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5) -- (exit3_trace2) node[near start, above] {\tiny{F}};
\draw[->] (node5.south) .. controls +(down:40mm) and +(left:28mm) .. (node5.west) node[near start , shift={(0.8,1.4)}] {\tiny{T}};

% Lines TRACE 4 (old TRACE 3)
\draw[->] (exit3.south) .. controls +(down:20mm) and +(left:5mm) .. (node6.west);

% Lines TRACE 5 (old TRACE 6)
\draw[->] (exit3_trace5.south) .. controls +(down:20mm) and +(left:5mm) .. (node12.west);

% Lines TRACE 6 (old TRACE 4)
\draw[->] (exit3_trace2.south) .. controls +(down:20mm) and +(left:5mm) .. (node7.west);
\draw[->] (node7) -- (node8) node[near start, right] {\tiny{T}};
\draw[->] (node7) -- (exit1_trace4) node[near start, above] {\tiny{F}};
\draw[->] (node8) -- (alias1_trace1);

% Frames
\node[label=TRACE 1, frame,fit= (node0) (node1) (node2) ]{};
\node[label=TRACE 3, frame,fit= (node3) (node4) (node5)]{};
\node[label=TRACE 4, frame,fit= (node6)]{};
\node[label=TRACE 6, frame,fit= (node7) (node8)]{};
\node[label=TRACE 2, frame,fit= (node9) (node10) (node11)]{};
\node[label=TRACE 5, frame,fit= (node12)]{};
\node[label={[shift={(-1,0)}]LOOP 2}, frame_loop,fit= (node11) ]{};
\node[label={[shift={(-1,0)}]LOOP 1}, frame_loop,fit= (node2) ]{};
\node[label={[shift={(-1,0)}]LOOP 3}, frame_loop,fit= (node5) ]{};

\end{tikzpicture}

}
\caption{Trace flow diagram loop with 3 inner loops}
\label{fig:3-inner-loops}
\end{adjustwidth}
\end{figure}


%-----------------------------------------------
% Function
%-----------------------------------------------
\section{Recursive functions}
In this section it will be shown what is the behaviour of the compiler when dealing with recursive functions. In particular, both non-tail recursive and tail recursive functions have been investigated.
\subsection{Non-tail recursive function}
This example consists in a non-tail recursive factorial function. The compiler does not create a loop structure because the function is non-tail recursive.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Non-tail recursive factorial

local function factorial(n)
  if n > 0 then
    return n * factorial(n-1)
  end
  return 1
end
\end{lstlisting}
\end{mdframed}

\noindent
The function calls itself as a standard recursive function because an operation occurs on the call result before returning. Since it is non-tail recursive, when making a recursive call, the return address needs to be pushed onto the call stack then jump to the called function. This means that it needs a call stack whose size is linear with the depth of the recursive calls.

In the bytecode below the depth of the recursive calls is represented by dots in the second column. In this case the compiler unrolls three recursive calls. Thus, the trace created contains three function calls with the instruction \texttt{FUNCF} (lines \texttt{0000}) and it ends with an up-recursion \texttt{-- TRACE 1 stop -> up-recursion}.
\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
0001  KSHORT   1   0
0002  ISGE     1   0
0003  JMP      1 => 0009
0004  UGET     1   0; factorial
0005  SUBVN    2   0   0  ; 1
0006  CALL     1   2   2
0000  . FUNCF    3  ; Ex.lua:3
0001  . KSHORT   1   0
0002  . ISGE     1   0
0003  . JMP      1 => 0009
0004  . UGET     1   0 ; factorial
0005  . SUBVN    2   0   0  ; 1
0006  . CALL     1   2   2
0000  . . FUNCF    3 ; Ex.lua:3
0001  . . KSHORT   1   0
0002  . . ISGE     1   0
0003  . . JMP      1 => 0009
0004  . . UGET     1   0 ; factorial
0005  . . SUBVN    2   0   0  ; 1
0006  . . CALL     1   2   2
0000  . . . FUNCF    3 ; Ex.lua:3
---- TRACE 1 stop -> up-recursion
\end{lstlisting}
\end{multicols}

\noindent
The IR generated is the following.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
---- TRACE 1 IR
0001 >  num SLOAD  #1    T
0002 >  num GT     0001  +0  
0003    fun SLOAD  #0    R
0004 >  fun EQ     0003  Ex.lua:3
0005    num SUB    0001  +1  
0006 >  num GT     0005  +0  
0007    num SUB    0005  +1  
0008 >  num GT     0007  +0  
0009    num SUB    0007  +1  
---- TRACE 1 stop -> up-recursion
\end{lstlisting}
\end{multicols}

\subsection{Tail recursive function}
This example consists in a tail recursive factorial function. In this case, the compiler create a loop structure because the function is tail recursive.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Tail recursive factorial

local function factorial(n, r)
  r = r or 1
  if n > 0 then
    return factorial(n-1, n*r)
  end
  return r
end
\end{lstlisting}
\end{mdframed}

\noindent
Since the function is tail recursive as soon as there is a return from the recursive call the execution flows goes immediately to a return as well. It skips the entire chain of recursive functions returning and it returns straight to the original caller. There is no need of a call stack for the recursive calls.

As a matter of fact, there are no dots in the bytecode below because there is no depth of recursive calls. Also in this case the compiler unrolls three recursive calls. Thus, the trace created contains three function calls with the instruction \texttt{FUNCF} (lines \texttt{0000}) and it ends with a tail recursion \texttt{-- TRACE 1 stop -> tail-recursion}.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
0001  IST          1
0002  JMP      2 => 0004
0004  KSHORT   2   0
0005  ISGE     2   0
0006  JMP      2 => 0011
0007  UGET     2   0; factorial
0008  SUBVN    3   0   0  ; 1
0009  MULVV    4   0   1
0010  CALLT    2   3
0000  FUNCF    5 ; Ex.lua:3
0001  IST          1
0002  JMP      2 => 0004
0004  KSHORT   2   0
0005  ISGE     2   0
0006  JMP      2 => 0011
0007  UGET     2   0 ; factorial
0008  SUBVN    3   0   0  ; 1
0009  MULVV    4   0   1
0010  CALLT    2   3
0000  FUNCF    5 ; Ex.lua:3
0001  IST          1
0002  JMP      2 => 0004
0004  KSHORT   2   0
0005  ISGE     2   0
0006  JMP      2 => 0011
0007  UGET     2   0 ; factorial
0008  SUBVN    3   0   0  ; 1
0009  MULVV    4   0   1
0010  CALLT    2   3
0000  FUNCF    5 ; Ex.lua:3
---- TRACE 1 stop -> tail-recursion
\end{lstlisting}
\end{multicols}

\noindent
The fact that the compiler transforms tail-recursive functions in loops is more explicit in the IR (see the \texttt{-- LOOP --} label at line \texttt{0014}). This is a standard compiler transformation.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:3
---- TRACE 1 IR
0001 >  num SLOAD  #2    T
0002 >  num SLOAD  #1    T
0003 >  num GT     0002  +0  
0004    fun SLOAD  #0    R
0005 >  fun EQ     0004  Ex.lua:3
0006    num SUB    0002  +1  
0007    num MUL    0002  0001
0008 >  num GT     0006  +0  
0009    num SUB    0006  +1  
0010    num MUL    0007  0006
0011 >  num GT     0009  +0  
0012  + num SUB    0009  +1  
0013  + num MUL    0010  0009
0014 ------ LOOP ------------
0015 >  num GT     0012  +0  
0016    num SUB    0012  +1  
0017    num MUL    0013  0012
0018 >  num GT     0016  +0  
0019    num SUB    0016  +1  
0020    num MUL    0017  0016
0021 >  num GT     0019  +0  
0022  + num SUB    0019  +1  
0023  + num MUL    0020  0019
0024    num PHI    0013  0023
0025    num PHI    0012  0022
---- TRACE 1 stop -> tail-recursion
\end{lstlisting}
\end{multicols}

\section{Stitch trace}
Trace stitching is a feature introduced in LuaJIT version 2.1 which allows traces to stop at a classic C function or a not-compiled built-in, return to the interpreter, run the C function or built-in and then start a new trace after it returns. This is not particularly efficient, but it avoids trace aborts due to NYI functions, which would previously force the whole code path around such a function to be interpreted.

Trace stitching can be seen as the equivalent of disabling the JIT (\texttt{jit.off()}) before calling a C function or built-in, then enabling the JIT (\texttt{jit.on()}) just after the function call.

The bytecode instructions in which trace stitching feature plays a role are the following:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|}
        \hline
        Bytecode ins & Description \\
        \hline
        \texttt{FUNCC} & Call C function via classic API\\
        \texttt{FUNCCW} & Call wrapped C function via classic API\\
        \hline
    \end{tabular}
    \caption{Bytecode instructions for stitch trace}
    \label{tab:stitch-bc-ins}
\end{table}

\noindent
Here we propose a concrete example which describes trace stitching.
\begin{mdframed}[style=LuaStyleFrame]
\begin{lstlisting}[style=LuaStyle]
-- Stitch trace

local x = 0

for i=1,100 do
	x = x + 11
	os.clock()
	x = x + 22
end
\end{lstlisting}
\end{mdframed}
\noindent
The bytecode instructions produced by LuaJIT are the following.

\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
0006  ADDVN    0   0   0  ; 11
0007  GGET     5   0      ; "os"
0008  TGETS    5   5   1  ; "clock"
0009  CALL     5   1   1
0000  . FUNCC             ; os.clock
---- TRACE 1 stop -> stitch
\end{lstlisting}

\columnbreak

\begin{lstlisting}[style=DumpStyle]
---- TRACE 2 start 1/stitch Ex.lua:7
0010  ADDVN    0   0   1  ; 22
0011  JFORL    1   1
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}
\noindent
The instruction \texttt{x=x+11} is computed into \texttt{TRACE 1}, then \texttt{os.clock()} is run by the interpreter, and finally \texttt{x=x+22} is computed into \texttt{TRACE 2}.

The IR respects the same logic: \texttt{TRACE 1} is a root trace which is linked to trace stitching at its end (\texttt{---- TRACE 1 stop -> stitch});  \texttt{TRACE 2} is a stitch trace connected to \texttt{TRACE 1} (\texttt{---- TRACE 2 start 1/stitch Ex.lua:7}, the number \texttt{1} refers to \texttt{TRACE 1}). Finally \texttt{TRACE 2} loops back to \texttt{TRACE 1} because we are considering a \texttt{for} loop.


\begin{multicols}{2}
\begin{lstlisting}[style=DumpStyle]
---- TRACE 1 start Ex.lua:5
---- TRACE 1 IR
....        SNAP   #0
0001    int SLOAD  #2    CI
0002 >  num SLOAD  #1    T
0003    num ADD    0002  +11 
0004    fun SLOAD  #0    R
0005    tab FLOAD  0004  func.env
0006    int FLOAD  0005  tab.hmask
0007 >  int EQ     0006  +63 
0008    p32 FLOAD  0005  tab.node
0009 >  p32 HREFK  0008  "os" @56
0010 >  tab HLOAD  0009
0011    int FLOAD  0010  tab.hmask
0012 >  int EQ     0011  +15 
0013    p32 FLOAD  0010  tab.node
0014 >  p32 HREFK  0013  "clock" @14
0015 >  fun HLOAD  0014
0016 >  fun EQ     0015  os.clock
0017    num CONV   0001  num.int
....        SNAP   #1
---- TRACE 1 stop -> stitch

---- TRACE 2 start 1/stitch Ex.lua:7
---- TRACE 2 IR
....        SNAP   #0
0001 >  num SLOAD  #1    T
0002    num ADD    0001  +22 
0003    num SLOAD  #2    I
0004    num ADD    0003  +1  
....        SNAP   #1
0005 >  num LE     0004  +100
....        SNAP   #2 
---- TRACE 2 stop -> 1
\end{lstlisting}
\end{multicols}
